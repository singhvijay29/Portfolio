{"ast":null,"code":"import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia(_ref) {\n  let {\n    keyframes,\n    velocity = 0.0,\n    power = 0.8,\n    timeConstant = 325,\n    bounceDamping = 10,\n    bounceStiffness = 500,\n    modifyTarget,\n    min,\n    max,\n    restDelta = 0.5,\n    restSpeed\n  } = _ref;\n  const origin = keyframes[0];\n  const state = {\n    done: false,\n    value: origin\n  };\n\n  const isOutOfBounds = v => min !== undefined && v < min || max !== undefined && v > max;\n\n  const nearestBoundary = v => {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  };\n\n  let amplitude = power * velocity;\n  const ideal = origin + amplitude;\n  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  /**\n   * If the target has changed we need to re-calculate the amplitude, otherwise\n   * the animation will start from the wrong position.\n   */\n\n  if (target !== ideal) amplitude = target - origin;\n\n  const calcDelta = t => -amplitude * Math.exp(-t / timeConstant);\n\n  const calcLatest = t => target + calcDelta(t);\n\n  const applyFriction = t => {\n    const delta = calcDelta(t);\n    const latest = calcLatest(t);\n    state.done = Math.abs(delta) <= restDelta;\n    state.value = state.done ? target : latest;\n  };\n  /**\n   * Ideally this would resolve for t in a stateless way, we could\n   * do that by always precalculating the animation but as we know\n   * this will be done anyway we can assume that spring will\n   * be discovered during that.\n   */\n\n\n  let timeReachedBoundary;\n  let spring$1;\n\n  const checkCatchBoundary = t => {\n    if (!isOutOfBounds(state.value)) return;\n    timeReachedBoundary = t;\n    spring$1 = spring({\n      keyframes: [state.value, nearestBoundary(state.value)],\n      velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n      // TODO: This should be passing * 1000\n      damping: bounceDamping,\n      stiffness: bounceStiffness,\n      restDelta,\n      restSpeed\n    });\n  };\n\n  checkCatchBoundary(0);\n  return {\n    calculatedDuration: null,\n    next: t => {\n      /**\n       * We need to resolve the friction to figure out if we need a\n       * spring but we don't want to do this twice per frame. So here\n       * we flag if we updated for this frame and later if we did\n       * we can skip doing it again.\n       */\n      let hasUpdatedFrame = false;\n\n      if (!spring$1 && timeReachedBoundary === undefined) {\n        hasUpdatedFrame = true;\n        applyFriction(t);\n        checkCatchBoundary(t);\n      }\n      /**\n       * If we have a spring and the provided t is beyond the moment the friction\n       * animation crossed the min/max boundary, use the spring.\n       */\n\n\n      if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n        return spring$1.next(t - timeReachedBoundary);\n      } else {\n        !hasUpdatedFrame && applyFriction(t);\n        return state;\n      }\n    }\n  };\n}\n\nexport { inertia };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/framer-motion/dist/es/animation/generators/inertia.mjs"],"names":["spring","calcGeneratorVelocity","inertia","keyframes","velocity","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","min","max","restDelta","restSpeed","origin","state","done","value","isOutOfBounds","v","undefined","nearestBoundary","Math","abs","amplitude","ideal","target","calcDelta","t","exp","calcLatest","applyFriction","delta","latest","timeReachedBoundary","spring$1","checkCatchBoundary","damping","stiffness","calculatedDuration","next","hasUpdatedFrame"],"mappings":"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","sourcesContent":["import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n"]},"metadata":{},"sourceType":"module"}