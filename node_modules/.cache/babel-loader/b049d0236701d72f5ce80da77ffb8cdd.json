{"ast":null,"code":"import { extractEventInfo } from '../../events/event-info.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { isPrimaryPointer } from '../../events/utils/is-primary-pointer.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n/**\n * @internal\n */\n\nclass PanSession {\n  constructor(event, handlers) {\n    let {\n      transformPagePoint,\n      contextWindow,\n      dragSnapToOrigin = false\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n    /**\n     * @internal\n     */\n\n    this.contextWindow = window;\n\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const info = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      const isDistancePastThreshold = distance2D(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        point\n      } = info;\n      const {\n        timestamp\n      } = frameData;\n      this.history.push({ ...point,\n        timestamp\n      });\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info);\n        this.startEvent = this.lastMoveEvent;\n      }\n\n      onMove && onMove(this.lastMoveEvent, info);\n    };\n\n    this.handlePointerMove = (event, info) => {\n      this.lastMoveEvent = event;\n      this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint); // Throttle mouse move event to once per frame\n\n      frame.update(this.updatePoint, true);\n    };\n\n    this.handlePointerUp = (event, info) => {\n      this.end();\n      const {\n        onEnd,\n        onSessionEnd,\n        resumeAnimation\n      } = this.handlers;\n      if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const panInfo = getPanInfo(event.type === \"pointercancel\" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);\n\n      if (this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n\n      onSessionEnd && onSessionEnd(event, panInfo);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (!isPrimaryPointer(event)) return;\n    this.dragSnapToOrigin = dragSnapToOrigin;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    this.contextWindow = contextWindow || window;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const {\n      point\n    } = initialInfo;\n    const {\n      timestamp\n    } = frameData;\n    this.history = [{ ...point,\n      timestamp\n    }];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n  }\n\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelFrame(this.updatePoint);\n  }\n\n}\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction getPanInfo(_ref, history) {\n  let {\n    point\n  } = _ref;\n  return {\n    point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nexport { PanSession };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs"],"names":["extractEventInfo","secondsToMilliseconds","millisecondsToSeconds","addPointerEvent","pipe","distance2D","isPrimaryPointer","frame","cancelFrame","frameData","PanSession","constructor","event","handlers","transformPagePoint","contextWindow","dragSnapToOrigin","startEvent","lastMoveEvent","lastMoveEventInfo","window","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","onStart","onMove","handlePointerMove","transformPoint","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","initialInfo","onSessionStart","removeListeners","updateHandlers","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","length","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"mappings":"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","sourcesContent":["import { extractEventInfo } from '../../events/event-info.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { isPrimaryPointer } from '../../events/utils/is-primary-pointer.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"]},"metadata":{},"sourceType":"module"}