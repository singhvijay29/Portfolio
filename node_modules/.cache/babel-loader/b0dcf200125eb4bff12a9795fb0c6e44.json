{"ast":null,"code":"'use client'; // src/use-tabs.ts\n\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { lazyDisclosure } from \"@chakra-ui/lazy-utils\";\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { useCallback, useEffect, useRef, useState, useId, createElement } from \"react\";\nvar [TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant] = createDescendantContext();\n\nfunction useTabs(props) {\n  var _a;\n\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props;\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex != null ? defaultIndex : 0);\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex != null ? defaultIndex : 0,\n    value: index,\n    onChange\n  });\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  const descendants = useTabsDescendants();\n  const uuid = useId();\n  const uid = (_a = props.id) != null ? _a : uuid;\n  const id = `tabs-${uid}`;\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps\n  };\n}\n\nvar [TabsProvider, useTabsContext] = createContext({\n  name: \"TabsContext\",\n  errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n});\n\nfunction useTabList(props) {\n  const {\n    focusedIndex,\n    orientation,\n    direction\n  } = useTabsContext();\n  const descendants = useTabsDescendantsContext();\n  const onKeyDown = useCallback(event => {\n    const nextTab = () => {\n      var _a;\n\n      const next = descendants.nextEnabled(focusedIndex);\n      if (next) (_a = next.node) == null ? void 0 : _a.focus();\n    };\n\n    const prevTab = () => {\n      var _a;\n\n      const prev = descendants.prevEnabled(focusedIndex);\n      if (prev) (_a = prev.node) == null ? void 0 : _a.focus();\n    };\n\n    const firstTab = () => {\n      var _a;\n\n      const first = descendants.firstEnabled();\n      if (first) (_a = first.node) == null ? void 0 : _a.focus();\n    };\n\n    const lastTab = () => {\n      var _a;\n\n      const last = descendants.lastEnabled();\n      if (last) (_a = last.node) == null ? void 0 : _a.focus();\n    };\n\n    const isHorizontal = orientation === \"horizontal\";\n    const isVertical = orientation === \"vertical\";\n    const eventKey = event.key;\n    const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\";\n    const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\";\n    const keyMap = {\n      [ArrowStart]: () => isHorizontal && prevTab(),\n      [ArrowEnd]: () => isHorizontal && nextTab(),\n      ArrowDown: () => isVertical && nextTab(),\n      ArrowUp: () => isVertical && prevTab(),\n      Home: firstTab,\n      End: lastTab\n    };\n    const action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, focusedIndex, orientation, direction]);\n  return { ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\n\nfunction useTab(props) {\n  const {\n    isDisabled = false,\n    isFocusable = false,\n    ...htmlProps\n  } = props;\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    selectedIndex\n  } = useTabsContext();\n  const {\n    index,\n    register\n  } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable\n  });\n  const isSelected = index === selectedIndex;\n\n  const onClick = () => {\n    setSelectedIndex(index);\n  };\n\n  const onFocus = () => {\n    setFocusedIndex(index);\n    const isDisabledButFocusable = isDisabled && isFocusable;\n    const shouldSelect = !isManual && !isDisabledButFocusable;\n\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n\n  const clickableProps = useClickable({ ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  });\n  const type = \"button\";\n  return { ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? void 0 : callAllHandlers(props.onFocus, onFocus)\n  };\n}\n\nvar [TabPanelProvider, useTabPanelContext] = createContext({});\n\nfunction useTabPanels(props) {\n  const context = useTabsContext();\n  const {\n    id,\n    selectedIndex\n  } = context;\n  const validChildren = getValidChildren(props.children);\n  const children = validChildren.map((child, index) => createElement(TabPanelProvider, {\n    key: index,\n    value: {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      tabId: makeTabId(id, index),\n      selectedIndex\n    }\n  }, child));\n  return { ...props,\n    children\n  };\n}\n\nfunction useTabPanel(props) {\n  const {\n    children,\n    ...htmlProps\n  } = props;\n  const {\n    isLazy,\n    lazyBehavior\n  } = useTabsContext();\n  const {\n    isSelected,\n    id,\n    tabId\n  } = useTabPanelContext();\n  const hasBeenSelected = useRef(false);\n\n  if (isSelected) {\n    hasBeenSelected.current = true;\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior\n  });\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id\n  };\n}\n\nfunction useTabIndicator() {\n  const context = useTabsContext();\n  const descendants = useTabsDescendantsContext();\n  const {\n    selectedIndex,\n    orientation\n  } = context;\n  const isHorizontal = orientation === \"horizontal\";\n  const isVertical = orientation === \"vertical\";\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return {\n      left: 0,\n      width: 0\n    };\n    if (isVertical) return {\n      top: 0,\n      height: 0\n    };\n    return void 0;\n  });\n  const [hasMeasured, setHasMeasured] = useState(false);\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return;\n    const tab = descendants.item(selectedIndex);\n    if (tab == null) return;\n\n    if (isHorizontal) {\n      setRect({\n        left: tab.node.offsetLeft,\n        width: tab.node.offsetWidth\n      });\n    }\n\n    if (isVertical) {\n      setRect({\n        top: tab.node.offsetTop,\n        height: tab.node.offsetHeight\n      });\n    }\n\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true);\n    });\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, descendants]);\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect\n  };\n}\n\nfunction makeTabId(id, index) {\n  return `${id}--tab-${index}`;\n}\n\nfunction makeTabPanelId(id, index) {\n  return `${id}--tabpanel-${index}`;\n}\n\nexport { TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant, useTabs, TabsProvider, useTabsContext, useTabList, useTab, useTabPanels, useTabPanel, useTabIndicator };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/tabs/src/use-tabs.ts"],"names":[],"mappings":"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","sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport { createContext } from \"@chakra-ui/react-context\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { lazyDisclosure, LazyMode } from \"@chakra-ui/lazy-utils\"\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useId,\n  createElement,\n} from \"react\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  TabsDescendantsProvider,\n  useTabsDescendantsContext,\n  useTabsDescendants,\n  useTabsDescendant,\n] = createDescendantContext<HTMLButtonElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   * @default \"horizontal\"\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   *\n   * @default false\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance 🚀:\n   * If `true`, rendering of the tab panel's will be deferred until it is selected.\n   * @default false\n   */\n  isLazy?: boolean\n  /**\n   * Performance 🚀:\n   * The lazy behavior of tab panels' content when not active.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The content of inactive tab panels are always unmounted.\n   * - \"keepMounted\": The content of inactive tab panels is initially unmounted,\n   * but stays mounted when selected.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyMode\n  /**\n   * The writing mode direction.\n   *\n   * - When in RTL, the left and right navigation is flipped\n   * @default \"ltr\"\n   */\n  direction?: \"rtl\" | \"ltr\"\n}\n\n/**\n * Tabs hook that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n  const descendants = useTabsDescendants()\n\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n  const uuid = useId()\n  const uid = props.id ?? uuid\n  const id = `tabs-${uid}`\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<\n  ReturnType<typeof useTabs>,\n  \"htmlProps\" | \"descendants\"\n>\n\nexport const [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const { focusedIndex, orientation, direction } = useTabsContext()\n\n  const descendants = useTabsDescendantsContext()\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => {\n        const next = descendants.nextEnabled(focusedIndex)\n        if (next) next.node?.focus()\n      }\n      const prevTab = () => {\n        const prev = descendants.prevEnabled(focusedIndex)\n        if (prev) prev.node?.focus()\n      }\n      const firstTab = () => {\n        const first = descendants.firstEnabled()\n        if (first) first.node?.focus()\n      }\n      const lastTab = () => {\n        const last = descendants.lastEnabled()\n        if (last) last.node?.focus()\n      }\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = event.key\n\n      const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\"\n      const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\"\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        [ArrowStart]: () => isHorizontal && prevTab(),\n        [ArrowEnd]: () => isHorizontal && nextTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, focusedIndex, orientation, direction],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true` and `isDisabled`, the `Tab` will be focusable but not interactive.\n   * @default false\n   */\n  isFocusable?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled = false, isFocusable = false, ...htmlProps } = props\n\n  const { setSelectedIndex, isManual, id, setFocusedIndex, selectedIndex } =\n    useTabsContext()\n\n  const { index, register } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    setFocusedIndex(index)\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\nconst [TabPanelProvider, useTabPanelContext] = createContext<{\n  isSelected: boolean\n  id: string\n  tabId: string\n  selectedIndex: number\n}>({})\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    createElement(\n      TabPanelProvider,\n      {\n        key: index,\n        value: {\n          isSelected: index === selectedIndex,\n          id: makeTabPanelId(id, index),\n          tabId: makeTabId(id, index),\n          selectedIndex,\n        },\n      },\n      child,\n    ),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Record<string, any>) {\n  const { children, ...htmlProps } = props\n  const { isLazy, lazyBehavior } = useTabsContext()\n  const { isSelected, id, tabId } = useTabPanelContext()\n\n  const hasBeenSelected = useRef(false)\n  if (isSelected) {\n    hasBeenSelected.current = true\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior,\n  })\n\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n  const descendants = useTabsDescendantsContext()\n\n  const { selectedIndex, orientation } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return\n\n    const tab = descendants.item(selectedIndex)\n    if (tab == null) return\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal) {\n      setRect({ left: tab.node.offsetLeft, width: tab.node.offsetWidth })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical) {\n      setRect({ top: tab.node.offsetTop, height: tab.node.offsetHeight })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, descendants])\n\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"]},"metadata":{},"sourceType":"module"}