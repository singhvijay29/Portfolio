{"ast":null,"code":"'use client'; // src/index.ts\n\nimport { getActiveElement, getAllFocusable, isTabbable } from \"@chakra-ui/dom-utils\";\nimport { useEventListener } from \"@chakra-ui/react-use-event-listener\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { useCallback, useRef } from \"react\";\n\nfunction preventReturnFocus(containerRef) {\n  const el = containerRef.current;\n  if (!el) return false;\n  const activeElement = getActiveElement(el);\n  if (!activeElement) return false;\n  if (el.contains(activeElement)) return false;\n  if (isTabbable(activeElement)) return true;\n  return false;\n}\n\nfunction useFocusOnHide(containerRef, options) {\n  const {\n    shouldFocus: shouldFocusProp,\n    visible,\n    focusRef\n  } = options;\n  const shouldFocus = shouldFocusProp && !visible;\n  useUpdateEffect(() => {\n    if (!shouldFocus) return;\n\n    if (preventReturnFocus(containerRef)) {\n      return;\n    }\n\n    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;\n    let rafId;\n\n    if (el) {\n      rafId = requestAnimationFrame(() => {\n        el.focus({\n          preventScroll: true\n        });\n      });\n      return () => {\n        cancelAnimationFrame(rafId);\n      };\n    }\n  }, [shouldFocus, containerRef, focusRef]);\n}\n\nvar defaultOptions = {\n  preventScroll: true,\n  shouldFocus: false\n};\n\nfunction useFocusOnShow(target) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;\n  const {\n    focusRef,\n    preventScroll,\n    shouldFocus,\n    visible\n  } = options;\n  const element = isRefObject(target) ? target.current : target;\n  const autoFocusValue = shouldFocus && visible;\n  const autoFocusRef = useRef(autoFocusValue);\n  const lastVisibleRef = useRef(visible);\n  useSafeLayoutEffect(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue;\n    }\n\n    lastVisibleRef.current = visible;\n  }, [visible, autoFocusValue]);\n  const onFocus = useCallback(() => {\n    if (!visible || !element || !autoFocusRef.current) return;\n    autoFocusRef.current = false;\n    if (element.contains(document.activeElement)) return;\n\n    if (focusRef == null ? void 0 : focusRef.current) {\n      requestAnimationFrame(() => {\n        var _a;\n\n        (_a = focusRef.current) == null ? void 0 : _a.focus({\n          preventScroll\n        });\n      });\n    } else {\n      const tabbableEls = getAllFocusable(element);\n\n      if (tabbableEls.length > 0) {\n        requestAnimationFrame(() => {\n          tabbableEls[0].focus({\n            preventScroll\n          });\n        });\n      }\n    }\n  }, [visible, preventScroll, element, focusRef]);\n  useUpdateEffect(() => {\n    onFocus();\n  }, [onFocus]);\n  useEventListener(element, \"transitionend\", onFocus);\n}\n\nfunction isRefObject(val) {\n  return \"current\" in val;\n}\n\nexport { useFocusOnHide, useFocusOnShow };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/react-use-focus-effect/src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  FocusableElement,\n  getActiveElement,\n  getAllFocusable,\n  isTabbable,\n} from \"@chakra-ui/dom-utils\"\nimport { useEventListener } from \"@chakra-ui/react-use-event-listener\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport type { RefObject } from \"react\"\nimport { useCallback, useRef } from \"react\"\n\nexport interface UseFocusOnHideOptions {\n  focusRef: RefObject<FocusableElement>\n  shouldFocus?: boolean\n  visible?: boolean\n}\n\nfunction preventReturnFocus(containerRef: React.RefObject<HTMLElement>) {\n  const el = containerRef.current\n  if (!el) return false\n\n  const activeElement = getActiveElement(el)\n\n  if (!activeElement) return false\n  if (el.contains(activeElement)) return false\n  if (isTabbable(activeElement)) return true\n\n  return false\n}\n\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\nexport function useFocusOnHide(\n  containerRef: RefObject<HTMLElement>,\n  options: UseFocusOnHideOptions,\n) {\n  const { shouldFocus: shouldFocusProp, visible, focusRef } = options\n\n  const shouldFocus = shouldFocusProp && !visible\n\n  useUpdateEffect(() => {\n    if (!shouldFocus) return\n\n    if (preventReturnFocus(containerRef)) {\n      return\n    }\n\n    const el = focusRef?.current || containerRef.current\n\n    let rafId: number\n\n    if (el) {\n      rafId = requestAnimationFrame(() => {\n        el.focus({ preventScroll: true })\n      })\n      return () => {\n        cancelAnimationFrame(rafId)\n      }\n    }\n  }, [shouldFocus, containerRef, focusRef])\n}\n\nexport interface UseFocusOnShowOptions {\n  visible?: boolean\n  shouldFocus?: boolean\n  preventScroll?: boolean\n  focusRef?: React.RefObject<FocusableElement>\n}\n\nconst defaultOptions: UseFocusOnShowOptions = {\n  preventScroll: true,\n  shouldFocus: false,\n}\n\nexport function useFocusOnShow<T extends HTMLElement>(\n  target: React.RefObject<T> | T,\n  options = defaultOptions,\n) {\n  const { focusRef, preventScroll, shouldFocus, visible } = options\n  const element = isRefObject(target) ? target.current : target\n\n  const autoFocusValue = shouldFocus && visible\n  const autoFocusRef = useRef(autoFocusValue)\n  const lastVisibleRef = useRef(visible)\n\n  useSafeLayoutEffect(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue\n    }\n    lastVisibleRef.current = visible\n  }, [visible, autoFocusValue])\n\n  const onFocus = useCallback(() => {\n    if (!visible || !element || !autoFocusRef.current) return\n    autoFocusRef.current = false\n\n    if (element.contains(document.activeElement as HTMLElement)) return\n\n    if (focusRef?.current) {\n      requestAnimationFrame(() => {\n        focusRef.current?.focus({ preventScroll })\n      })\n    } else {\n      const tabbableEls = getAllFocusable(element)\n      if (tabbableEls.length > 0) {\n        requestAnimationFrame(() => {\n          tabbableEls[0].focus({ preventScroll })\n        })\n      }\n    }\n  }, [visible, preventScroll, element, focusRef])\n\n  useUpdateEffect(() => {\n    onFocus()\n  }, [onFocus])\n\n  useEventListener(element, \"transitionend\", onFocus)\n}\n\nfunction isRefObject(val: any): val is { current: any } {\n  return \"current\" in val\n}\n"]},"metadata":{},"sourceType":"module"}