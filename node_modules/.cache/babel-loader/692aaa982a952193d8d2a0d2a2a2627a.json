{"ast":null,"code":"'use client';\n\nimport { useShortcut } from \"./chunk-YSKACL7R.mjs\";\nimport { getNextItemFromSearch } from \"./chunk-BWUXSGSJ.mjs\"; // src/use-menu.ts\n\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { useFocusOnHide } from \"@chakra-ui/react-use-focus-effect\";\nimport { usePopper } from \"@chakra-ui/popper\";\nimport { useDisclosure } from \"@chakra-ui/react-use-disclosure\";\nimport { useOutsideClick } from \"@chakra-ui/react-use-outside-click\";\nimport { useAnimationState } from \"@chakra-ui/react-use-animation-state\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { dataAttr, callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { lazyDisclosure } from \"@chakra-ui/lazy-utils\";\nimport { cloneElement, useCallback, useRef, useState, useId, useMemo, useEffect } from \"react\";\nvar [MenuDescendantsProvider, useMenuDescendantsContext, useMenuDescendants, useMenuDescendant] = createDescendantContext();\nvar [MenuProvider, useMenuContext] = createContext({\n  strict: false,\n  name: \"MenuContext\"\n});\n\nfunction useIds(idProp) {\n  for (var _len = arguments.length, prefixes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    prefixes[_key - 1] = arguments[_key];\n  }\n\n  const reactId = useId();\n  const id = idProp || reactId;\n  return useMemo(() => {\n    return prefixes.map(prefix => `${prefix}-${id}`);\n  }, [id, prefixes]);\n}\n\nfunction getOwnerDocument(node) {\n  var _a;\n\n  return (_a = node == null ? void 0 : node.ownerDocument) != null ? _a : document;\n}\n\nfunction isActiveElement(element) {\n  const doc = getOwnerDocument(element);\n  return doc.activeElement === element;\n}\n\nfunction useMenu() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    id,\n    closeOnSelect = true,\n    closeOnBlur = true,\n    initialFocusRef,\n    autoSelect = true,\n    isLazy,\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n    placement = \"bottom-start\",\n    lazyBehavior = \"unmount\",\n    direction,\n    computePositionOnMount = false,\n    ...popperProps\n  } = props;\n  const menuRef = useRef(null);\n  const buttonRef = useRef(null);\n  const descendants = useMenuDescendants();\n  const focusMenu = useCallback(() => {\n    requestAnimationFrame(() => {\n      var _a;\n\n      (_a = menuRef.current) == null ? void 0 : _a.focus({\n        preventScroll: false\n      });\n    });\n  }, []);\n  const focusFirstItem = useCallback(() => {\n    const id2 = setTimeout(() => {\n      var _a;\n\n      if (initialFocusRef) {\n        (_a = initialFocusRef.current) == null ? void 0 : _a.focus();\n      } else {\n        const first = descendants.firstEnabled();\n        if (first) setFocusedIndex(first.index);\n      }\n    });\n    timeoutIds.current.add(id2);\n  }, [descendants, initialFocusRef]);\n  const focusLastItem = useCallback(() => {\n    const id2 = setTimeout(() => {\n      const last = descendants.lastEnabled();\n      if (last) setFocusedIndex(last.index);\n    });\n    timeoutIds.current.add(id2);\n  }, [descendants]);\n  const onOpenInternal = useCallback(() => {\n    onOpenProp == null ? void 0 : onOpenProp();\n\n    if (autoSelect) {\n      focusFirstItem();\n    } else {\n      focusMenu();\n    }\n  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);\n  const {\n    isOpen,\n    onOpen,\n    onClose,\n    onToggle\n  } = useDisclosure({\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenInternal\n  });\n  useOutsideClick({\n    enabled: isOpen && closeOnBlur,\n    ref: menuRef,\n    handler: event => {\n      var _a;\n\n      if (!((_a = buttonRef.current) == null ? void 0 : _a.contains(event.target))) {\n        onClose();\n      }\n    }\n  });\n  const popper = usePopper({ ...popperProps,\n    enabled: isOpen || computePositionOnMount,\n    placement,\n    direction\n  });\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  useUpdateEffect(() => {\n    if (!isOpen) {\n      setFocusedIndex(-1);\n    }\n  }, [isOpen]);\n  useFocusOnHide(menuRef, {\n    focusRef: buttonRef,\n    visible: isOpen,\n    shouldFocus: true\n  });\n  const animationState = useAnimationState({\n    isOpen,\n    ref: menuRef\n  });\n  const [buttonId, menuId] = useIds(id, `menu-button`, `menu-list`);\n  const openAndFocusMenu = useCallback(() => {\n    onOpen();\n    focusMenu();\n  }, [onOpen, focusMenu]);\n  const timeoutIds = useRef( /* @__PURE__ */new Set([]));\n  useEffect(() => {\n    const ids = timeoutIds.current;\n    return () => {\n      ids.forEach(id2 => clearTimeout(id2));\n      ids.clear();\n    };\n  }, []);\n  const openAndFocusFirstItem = useCallback(() => {\n    onOpen();\n    focusFirstItem();\n  }, [focusFirstItem, onOpen]);\n  const openAndFocusLastItem = useCallback(() => {\n    onOpen();\n    focusLastItem();\n  }, [onOpen, focusLastItem]);\n  const refocus = useCallback(() => {\n    var _a, _b;\n\n    const doc = getOwnerDocument(menuRef.current);\n    const hasFocusWithin = (_a = menuRef.current) == null ? void 0 : _a.contains(doc.activeElement);\n    const shouldRefocus = isOpen && !hasFocusWithin;\n    if (!shouldRefocus) return;\n    const node = (_b = descendants.item(focusedIndex)) == null ? void 0 : _b.node;\n    node == null ? void 0 : node.focus({\n      preventScroll: true\n    });\n  }, [isOpen, focusedIndex, descendants]);\n  const rafId = useRef(null);\n  return {\n    openAndFocusMenu,\n    openAndFocusFirstItem,\n    openAndFocusLastItem,\n    onTransitionEnd: refocus,\n    unstable__animationState: animationState,\n    descendants,\n    popper,\n    buttonId,\n    menuId,\n    forceUpdate: popper.forceUpdate,\n    orientation: \"vertical\",\n    isOpen,\n    onToggle,\n    onOpen,\n    onClose,\n    menuRef,\n    buttonRef,\n    focusedIndex,\n    closeOnSelect,\n    closeOnBlur,\n    autoSelect,\n    setFocusedIndex,\n    isLazy,\n    lazyBehavior,\n    initialFocusRef,\n    rafId\n  };\n}\n\nfunction useMenuButton() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let externalRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const menu = useMenuContext();\n  const {\n    onToggle,\n    popper,\n    openAndFocusFirstItem,\n    openAndFocusLastItem\n  } = menu;\n  const onKeyDown = useCallback(event => {\n    const eventKey = event.key;\n    const keyMap = {\n      Enter: openAndFocusFirstItem,\n      ArrowDown: openAndFocusFirstItem,\n      ArrowUp: openAndFocusLastItem\n    };\n    const action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n    }\n  }, [openAndFocusFirstItem, openAndFocusLastItem]);\n  return { ...props,\n    ref: mergeRefs(menu.buttonRef, externalRef, popper.referenceRef),\n    id: menu.buttonId,\n    \"data-active\": dataAttr(menu.isOpen),\n    \"aria-expanded\": menu.isOpen,\n    \"aria-haspopup\": \"menu\",\n    \"aria-controls\": menu.menuId,\n    onClick: callAllHandlers(props.onClick, onToggle),\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\n\nfunction isTargetMenuItem(target) {\n  var _a;\n\n  return isHTMLElement(target) && !!((_a = target == null ? void 0 : target.getAttribute(\"role\")) == null ? void 0 : _a.startsWith(\"menuitem\"));\n}\n\nfunction useMenuList() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const menu = useMenuContext();\n\n  if (!menu) {\n    throw new Error(`useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`);\n  }\n\n  const {\n    focusedIndex,\n    setFocusedIndex,\n    menuRef,\n    isOpen,\n    onClose,\n    menuId,\n    isLazy,\n    lazyBehavior,\n    unstable__animationState: animated\n  } = menu;\n  const descendants = useMenuDescendantsContext();\n  const createTypeaheadHandler = useShortcut({\n    preventDefault: event => event.key !== \" \" && isTargetMenuItem(event.target)\n  });\n  const onKeyDown = useCallback(event => {\n    if (!event.currentTarget.contains(event.target)) return;\n    const eventKey = event.key;\n    const keyMap = {\n      Tab: event2 => event2.preventDefault(),\n      Escape: onClose,\n      ArrowDown: () => {\n        const next = descendants.nextEnabled(focusedIndex);\n        if (next) setFocusedIndex(next.index);\n      },\n      ArrowUp: () => {\n        const prev = descendants.prevEnabled(focusedIndex);\n        if (prev) setFocusedIndex(prev.index);\n      }\n    };\n    const fn = keyMap[eventKey];\n\n    if (fn) {\n      event.preventDefault();\n      fn(event);\n      return;\n    }\n\n    const onTypeahead = createTypeaheadHandler(character => {\n      const nextItem = getNextItemFromSearch(descendants.values(), character, item => {\n        var _a, _b;\n\n        return (_b = (_a = item == null ? void 0 : item.node) == null ? void 0 : _a.textContent) != null ? _b : \"\";\n      }, descendants.item(focusedIndex));\n\n      if (nextItem) {\n        const index = descendants.indexOf(nextItem.node);\n        setFocusedIndex(index);\n      }\n    });\n\n    if (isTargetMenuItem(event.target)) {\n      onTypeahead(event);\n    }\n  }, [descendants, focusedIndex, createTypeaheadHandler, onClose, setFocusedIndex]);\n  const hasBeenOpened = useRef(false);\n\n  if (isOpen) {\n    hasBeenOpened.current = true;\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenOpened.current,\n    enabled: isLazy,\n    mode: lazyBehavior,\n    isSelected: animated.present\n  });\n  return { ...props,\n    ref: mergeRefs(menuRef, ref),\n    children: shouldRenderChildren ? props.children : null,\n    tabIndex: -1,\n    role: \"menu\",\n    id: menuId,\n    style: { ...props.style,\n      transformOrigin: \"var(--popper-transform-origin)\"\n    },\n    \"aria-orientation\": \"vertical\",\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\n\nfunction useMenuPositioner() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    popper,\n    isOpen\n  } = useMenuContext();\n  return popper.getPopperProps({ ...props,\n    style: {\n      visibility: isOpen ? \"visible\" : \"hidden\",\n      ...props.style\n    }\n  });\n}\n\nfunction useMenuItem() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let externalRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const {\n    onMouseEnter: onMouseEnterProp,\n    onMouseMove: onMouseMoveProp,\n    onMouseLeave: onMouseLeaveProp,\n    onClick: onClickProp,\n    onFocus: onFocusProp,\n    isDisabled,\n    isFocusable,\n    closeOnSelect,\n    type: typeProp,\n    ...htmlProps\n  } = props;\n  const menu = useMenuContext();\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    closeOnSelect: menuCloseOnSelect,\n    onClose,\n    menuRef,\n    isOpen,\n    menuId,\n    rafId\n  } = menu;\n  const ref = useRef(null);\n  const id = `${menuId}-menuitem-${useId()}`;\n  const {\n    index,\n    register\n  } = useMenuDescendant({\n    disabled: isDisabled && !isFocusable\n  });\n  const onMouseEnter = useCallback(event => {\n    onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);\n    if (isDisabled) return;\n    setFocusedIndex(index);\n  }, [setFocusedIndex, index, isDisabled, onMouseEnterProp]);\n  const onMouseMove = useCallback(event => {\n    onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);\n\n    if (ref.current && !isActiveElement(ref.current)) {\n      onMouseEnter(event);\n    }\n  }, [onMouseEnter, onMouseMoveProp]);\n  const onMouseLeave = useCallback(event => {\n    onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);\n    if (isDisabled) return;\n    setFocusedIndex(-1);\n  }, [setFocusedIndex, isDisabled, onMouseLeaveProp]);\n  const onClick = useCallback(event => {\n    onClickProp == null ? void 0 : onClickProp(event);\n    if (!isTargetMenuItem(event.currentTarget)) return;\n\n    if (closeOnSelect != null ? closeOnSelect : menuCloseOnSelect) {\n      onClose();\n    }\n  }, [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]);\n  const onFocus = useCallback(event => {\n    onFocusProp == null ? void 0 : onFocusProp(event);\n    setFocusedIndex(index);\n  }, [setFocusedIndex, onFocusProp, index]);\n  const isFocused = index === focusedIndex;\n  const trulyDisabled = isDisabled && !isFocusable;\n  useUpdateEffect(() => {\n    if (!isOpen) return;\n\n    if (isFocused && !trulyDisabled && ref.current) {\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current);\n      }\n\n      rafId.current = requestAnimationFrame(() => {\n        var _a;\n\n        (_a = ref.current) == null ? void 0 : _a.focus({\n          preventScroll: true\n        });\n        rafId.current = null;\n      });\n    } else if (menuRef.current && !isActiveElement(menuRef.current)) {\n      menuRef.current.focus({\n        preventScroll: true\n      });\n    }\n\n    return () => {\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current);\n      }\n    };\n  }, [isFocused, trulyDisabled, menuRef, isOpen]);\n  const clickableProps = useClickable({\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    ref: mergeRefs(register, ref, externalRef),\n    isDisabled,\n    isFocusable\n  });\n  return { ...htmlProps,\n    ...clickableProps,\n    type: typeProp != null ? typeProp : clickableProps.type,\n    id,\n    role: \"menuitem\",\n    tabIndex: isFocused ? 0 : -1\n  };\n}\n\nfunction useMenuOption() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const {\n    type = \"radio\",\n    isChecked,\n    ...rest\n  } = props;\n  const ownProps = useMenuItem(rest, ref);\n  return { ...ownProps,\n    role: `menuitem${type}`,\n    \"aria-checked\": isChecked\n  };\n}\n\nfunction useMenuOptionGroup() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    children,\n    type = \"radio\",\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp,\n    ...htmlProps\n  } = props;\n  const isRadio = type === \"radio\";\n  const fallback = isRadio ? \"\" : [];\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue != null ? defaultValue : fallback,\n    value: valueProp,\n    onChange: onChangeProp\n  });\n  const onChange = useCallback(selectedValue => {\n    if (type === \"radio\" && typeof value === \"string\") {\n      setValue(selectedValue);\n    }\n\n    if (type === \"checkbox\" && Array.isArray(value)) {\n      const nextValue = value.includes(selectedValue) ? value.filter(item => item !== selectedValue) : value.concat(selectedValue);\n      setValue(nextValue);\n    }\n  }, [value, setValue, type]);\n  const validChildren = getValidChildren(children);\n  const clones = validChildren.map(child => {\n    if (child.type.id !== \"MenuItemOption\") return child;\n\n    const onClick = event => {\n      var _a, _b;\n\n      onChange(child.props.value);\n      (_b = (_a = child.props).onClick) == null ? void 0 : _b.call(_a, event);\n    };\n\n    const isChecked = type === \"radio\" ? child.props.value === value : value.includes(child.props.value);\n    return cloneElement(child, {\n      type,\n      onClick,\n      isChecked\n    });\n  });\n  return { ...htmlProps,\n    children: clones\n  };\n}\n\nfunction useMenuState() {\n  const {\n    isOpen,\n    onClose\n  } = useMenuContext();\n  return {\n    isOpen,\n    onClose\n  };\n}\n\nfunction isHTMLElement(el) {\n  var _a;\n\n  if (!isElement(el)) return false;\n  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;\n  return el instanceof win.HTMLElement;\n}\n\nfunction isElement(el) {\n  return el != null && typeof el == \"object\" && \"nodeType\" in el && el.nodeType === Node.ELEMENT_NODE;\n}\n\nexport { MenuDescendantsProvider, useMenuDescendantsContext, useMenuDescendants, useMenuDescendant, MenuProvider, useMenuContext, useMenu, useMenuButton, useMenuList, useMenuPositioner, useMenuItem, useMenuOption, useMenuOptionGroup, useMenuState };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/menu/src/use-menu.ts"],"names":["id","event"],"mappings":"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","sourcesContent":["import { useClickable } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport { useFocusOnHide } from \"@chakra-ui/react-use-focus-effect\"\nimport { usePopper, UsePopperProps } from \"@chakra-ui/popper\"\nimport {\n  useDisclosure,\n  UseDisclosureProps,\n} from \"@chakra-ui/react-use-disclosure\"\nimport { useOutsideClick } from \"@chakra-ui/react-use-outside-click\"\nimport { useAnimationState } from \"@chakra-ui/react-use-animation-state\"\nimport { createContext } from \"@chakra-ui/react-context\"\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { dataAttr, callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport { lazyDisclosure, LazyMode } from \"@chakra-ui/lazy-utils\"\n\nimport React, {\n  cloneElement,\n  useCallback,\n  useRef,\n  useState,\n  useId,\n  useMemo,\n  useEffect,\n} from \"react\"\nimport { useShortcut } from \"./use-shortcut\"\nimport { getNextItemFromSearch } from \"./get-next-item-from-search\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  MenuDescendantsProvider,\n  useMenuDescendantsContext,\n  useMenuDescendants,\n  useMenuDescendant,\n] = createDescendantContext<HTMLElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track menu state and logic\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [MenuProvider, useMenuContext] = createContext<\n  Omit<UseMenuReturn, \"descendants\">\n>({\n  strict: false,\n  name: \"MenuContext\",\n})\n\n/* -------------------------------------------------------------------------------------------------\n * useMenu hook\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuProps\n  extends Omit<UsePopperProps, \"enabled\">,\n    UseDisclosureProps {\n  /**\n   * The `ref` of the element that should receive focus when the popover opens.\n   */\n  initialFocusRef?: React.RefObject<{ focus(): void }>\n  /**\n   * If `true`, the menu will close when a menu item is\n   * clicked\n   *\n   * @default true\n   */\n  closeOnSelect?: boolean\n  /**\n   * If `true`, the menu will close when you click outside\n   * the menu list\n   *\n   * @default true\n   */\n  closeOnBlur?: boolean\n  /**\n   * If `true`, the first enabled menu item will receive focus and be selected\n   * when the menu opens.\n   *\n   * @default true\n   */\n  autoSelect?: boolean\n  /**\n   * Performance 🚀:\n   * If `true`, the MenuItem rendering will be deferred\n   * until the menu is open.\n   *\n   * @default false\n   */\n  isLazy?: boolean\n  /**\n   * Performance 🚀:\n   * The lazy behavior of menu's content when not visible.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The menu's content is always unmounted when not open.\n   * - \"keepMounted\": The menu's content initially unmounted,\n   * but stays mounted when menu is open.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyMode\n  /**\n   * If `rtl`, proper placement positions will be flipped i.e. 'top-right' will\n   * become 'top-left' and vice-verse\n   */\n  direction?: \"ltr\" | \"rtl\"\n  /*\n   * If `true`, the menu will be positioned when it mounts\n   * (even if it's not open).\n   *\n   * Note 🚨: We don't recommend using this in a menu/popover intensive UI or page\n   * as it might affect scrolling performance.\n   *\n   * @default false\n   */\n  computePositionOnMount?: boolean\n}\n\nfunction useIds(idProp?: string, ...prefixes: string[]) {\n  const reactId = useId()\n  const id = idProp || reactId\n  return useMemo(() => {\n    return prefixes.map((prefix) => `${prefix}-${id}`)\n  }, [id, prefixes])\n}\n\nfunction getOwnerDocument(node?: Element | null): Document {\n  return node?.ownerDocument ?? document\n}\n\nfunction isActiveElement(element: HTMLElement) {\n  const doc = getOwnerDocument(element)\n  return doc.activeElement === (element as HTMLElement)\n}\n\n/**\n * React Hook to manage a menu\n *\n * It provides the logic and will be used with react context\n * to propagate its return value to all children\n */\nexport function useMenu(props: UseMenuProps = {}) {\n  const {\n    id,\n    closeOnSelect = true,\n    closeOnBlur = true,\n    initialFocusRef,\n    autoSelect = true,\n    isLazy,\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n    placement = \"bottom-start\",\n    lazyBehavior = \"unmount\",\n    direction,\n    computePositionOnMount = false,\n    ...popperProps\n  } = props\n  /**\n   * Prepare the reference to the menu and disclosure\n   */\n  const menuRef = useRef<HTMLDivElement>(null)\n  const buttonRef = useRef<HTMLButtonElement>(null)\n\n  /**\n   * Context to register all menu item nodes\n   */\n  const descendants = useMenuDescendants()\n\n  const focusMenu = useCallback(() => {\n    requestAnimationFrame(() => {\n      menuRef.current?.focus({ preventScroll: false })\n    })\n  }, [])\n\n  const focusFirstItem = useCallback(() => {\n    const id = setTimeout(() => {\n      if (initialFocusRef) {\n        initialFocusRef.current?.focus()\n      } else {\n        const first = descendants.firstEnabled()\n        if (first) setFocusedIndex(first.index)\n      }\n    })\n    timeoutIds.current.add(id)\n  }, [descendants, initialFocusRef])\n\n  const focusLastItem = useCallback(() => {\n    const id = setTimeout(() => {\n      const last = descendants.lastEnabled()\n      if (last) setFocusedIndex(last.index)\n    })\n    timeoutIds.current.add(id)\n  }, [descendants])\n\n  const onOpenInternal = useCallback(() => {\n    onOpenProp?.()\n    if (autoSelect) {\n      focusFirstItem()\n    } else {\n      focusMenu()\n    }\n  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp])\n\n  const { isOpen, onOpen, onClose, onToggle } = useDisclosure({\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenInternal,\n  })\n\n  useOutsideClick({\n    enabled: isOpen && closeOnBlur,\n    ref: menuRef,\n    handler: (event) => {\n      if (!buttonRef.current?.contains(event.target as HTMLElement)) {\n        onClose()\n      }\n    },\n  })\n\n  /**\n   * Add some popper.js for dynamic positioning\n   */\n  const popper: any = usePopper({\n    ...popperProps,\n    enabled: isOpen || computePositionOnMount,\n    placement,\n    direction,\n  })\n\n  const [focusedIndex, setFocusedIndex] = useState(-1)\n\n  /**\n   * Focus the button when we close the menu\n   */\n  useUpdateEffect(() => {\n    if (!isOpen) {\n      setFocusedIndex(-1)\n    }\n  }, [isOpen])\n\n  useFocusOnHide(menuRef, {\n    focusRef: buttonRef,\n    visible: isOpen,\n    shouldFocus: true,\n  })\n\n  const animationState = useAnimationState({ isOpen, ref: menuRef })\n\n  /**\n   * Generate unique ids for menu's list and button\n   */\n  const [buttonId, menuId] = useIds(id, `menu-button`, `menu-list`)\n\n  const openAndFocusMenu = useCallback(() => {\n    onOpen()\n    focusMenu()\n  }, [onOpen, focusMenu])\n\n  const timeoutIds = useRef<Set<any>>(new Set([]))\n\n  // clean up timeouts\n  useEffect(() => {\n    const ids = timeoutIds.current\n    return () => {\n      ids.forEach((id) => clearTimeout(id))\n      ids.clear()\n    }\n  }, [])\n\n  const openAndFocusFirstItem = useCallback(() => {\n    onOpen()\n    focusFirstItem()\n  }, [focusFirstItem, onOpen])\n\n  const openAndFocusLastItem = useCallback(() => {\n    onOpen()\n    focusLastItem()\n  }, [onOpen, focusLastItem])\n\n  const refocus = useCallback(() => {\n    const doc = getOwnerDocument(menuRef.current)\n    const hasFocusWithin = menuRef.current?.contains(doc.activeElement)\n    const shouldRefocus = isOpen && !hasFocusWithin\n\n    if (!shouldRefocus) return\n\n    const node = descendants.item(focusedIndex)?.node\n    node?.focus({ preventScroll: true })\n  }, [isOpen, focusedIndex, descendants])\n\n  /**\n   * Track the animation frame which is scheduled to focus\n   * a menu item, so it can be cancelled if another item\n   * is focused before the animation executes. This prevents\n   * infinite rerenders.\n   */\n  const rafId = useRef<number | null>(null)\n\n  return {\n    openAndFocusMenu,\n    openAndFocusFirstItem,\n    openAndFocusLastItem,\n    onTransitionEnd: refocus,\n    unstable__animationState: animationState,\n    descendants,\n    popper,\n    buttonId,\n    menuId,\n    forceUpdate: popper.forceUpdate,\n    orientation: \"vertical\",\n    isOpen,\n    onToggle,\n    onOpen,\n    onClose,\n    menuRef,\n    buttonRef,\n    focusedIndex,\n    closeOnSelect,\n    closeOnBlur,\n    autoSelect,\n    setFocusedIndex,\n    isLazy,\n    lazyBehavior,\n    initialFocusRef,\n    rafId,\n  }\n}\n\nexport interface UseMenuReturn extends ReturnType<typeof useMenu> {}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuButton hook\n * -----------------------------------------------------------------------------------------------*/\nexport interface UseMenuButtonProps\n  extends Omit<React.HTMLAttributes<Element>, \"color\"> {}\n\n/**\n * React Hook to manage a menu button.\n *\n * The assumption here is that the `useMenu` hook is used\n * in a component higher up the tree, and its return value\n * is passed as `context` to this hook.\n */\nexport function useMenuButton(\n  props: UseMenuButtonProps = {},\n  externalRef: React.Ref<any> = null,\n) {\n  const menu = useMenuContext()\n\n  const { onToggle, popper, openAndFocusFirstItem, openAndFocusLastItem } = menu\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = event.key\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        Enter: openAndFocusFirstItem,\n        ArrowDown: openAndFocusFirstItem,\n        ArrowUp: openAndFocusLastItem,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n      }\n    },\n    [openAndFocusFirstItem, openAndFocusLastItem],\n  )\n\n  return {\n    ...props,\n    ref: mergeRefs(menu.buttonRef, externalRef, popper.referenceRef),\n    id: menu.buttonId,\n    \"data-active\": dataAttr(menu.isOpen),\n    \"aria-expanded\": menu.isOpen,\n    \"aria-haspopup\": \"menu\" as React.AriaAttributes[\"aria-haspopup\"],\n    \"aria-controls\": menu.menuId,\n    onClick: callAllHandlers(props.onClick, onToggle),\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nfunction isTargetMenuItem(target: EventTarget | null) {\n  // this will catch `menuitem`, `menuitemradio`, `menuitemcheckbox`\n  return (\n    isHTMLElement(target) &&\n    !!target?.getAttribute(\"role\")?.startsWith(\"menuitem\")\n  )\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuList\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuListProps\n  extends Omit<React.HTMLAttributes<Element>, \"color\"> {}\n\n/**\n * React Hook to manage a menu list.\n *\n * The assumption here is that the `useMenu` hook is used\n * in a component higher up the tree, and its return value\n * is passed as `context` to this hook.\n */\nexport function useMenuList(\n  props: UseMenuListProps = {},\n  ref: React.Ref<any> = null,\n): React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement> {\n  const menu = useMenuContext()\n\n  if (!menu) {\n    throw new Error(\n      `useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`,\n    )\n  }\n\n  const {\n    focusedIndex,\n    setFocusedIndex,\n    menuRef,\n    isOpen,\n    onClose,\n    menuId,\n    isLazy,\n    lazyBehavior,\n    unstable__animationState: animated,\n  } = menu\n\n  const descendants = useMenuDescendantsContext()\n\n  /**\n   * Hook that creates a keydown event handler that listens\n   * to printable keyboard character press\n   */\n  const createTypeaheadHandler = useShortcut({\n    preventDefault: (event) =>\n      event.key !== \" \" && isTargetMenuItem(event.target),\n  })\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      // ignore events bubbles from portal children\n      if (!event.currentTarget.contains(event.target as Element)) return\n\n      const eventKey = event.key\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        Tab: (event) => event.preventDefault(),\n        Escape: onClose,\n        ArrowDown: () => {\n          const next = descendants.nextEnabled(focusedIndex)\n          if (next) setFocusedIndex(next.index)\n        },\n        ArrowUp: () => {\n          const prev = descendants.prevEnabled(focusedIndex)\n          if (prev) setFocusedIndex(prev.index)\n        },\n      }\n\n      const fn = keyMap[eventKey]\n\n      if (fn) {\n        event.preventDefault()\n        fn(event)\n        return\n      }\n\n      /**\n       * Typeahead: Based on current character pressed,\n       * find the next item to be selected\n       */\n      const onTypeahead = createTypeaheadHandler((character) => {\n        const nextItem = getNextItemFromSearch(\n          descendants.values(),\n          character,\n          (item) => item?.node?.textContent ?? \"\",\n          descendants.item(focusedIndex),\n        )\n        if (nextItem) {\n          const index = descendants.indexOf(nextItem.node)\n          setFocusedIndex(index)\n        }\n      })\n\n      if (isTargetMenuItem(event.target)) {\n        onTypeahead(event)\n      }\n    },\n    [\n      descendants,\n      focusedIndex,\n      createTypeaheadHandler,\n      onClose,\n      setFocusedIndex,\n    ],\n  )\n\n  const hasBeenOpened = useRef(false)\n  if (isOpen) {\n    hasBeenOpened.current = true\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenOpened.current,\n    enabled: isLazy,\n    mode: lazyBehavior,\n    isSelected: animated.present,\n  })\n\n  return {\n    ...props,\n    ref: mergeRefs(menuRef, ref),\n    children: shouldRenderChildren ? props.children : null,\n    tabIndex: -1,\n    role: \"menu\",\n    id: menuId,\n    style: {\n      ...props.style,\n      transformOrigin: \"var(--popper-transform-origin)\",\n    },\n    \"aria-orientation\": \"vertical\" as React.AriaAttributes[\"aria-orientation\"],\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuPosition: Composes usePopper to position the menu\n * -----------------------------------------------------------------------------------------------*/\n\nexport function useMenuPositioner(props: any = {}) {\n  const { popper, isOpen } = useMenuContext()\n  return popper.getPopperProps({\n    ...props,\n    style: {\n      visibility: isOpen ? \"visible\" : \"hidden\",\n      ...props.style,\n    },\n  })\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuItem: Hook for each menu item within the menu list.\n   We also use it in `useMenuItemOption`\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuItemProps\n  extends Omit<React.HTMLAttributes<Element>, \"color\" | \"disabled\"> {\n  /**\n   * If `true`, the menuitem will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true` and the menuitem is disabled, it'll\n   * remain keyboard-focusable\n   */\n  isFocusable?: boolean\n  /**\n   * Overrides the parent menu's `closeOnSelect` prop.\n   */\n  closeOnSelect?: boolean\n  /**\n   * The type of the menuitem.\n   */\n  type?: React.ButtonHTMLAttributes<HTMLButtonElement>[\"type\"]\n}\n\nexport function useMenuItem(\n  props: UseMenuItemProps = {},\n  externalRef: React.Ref<any> = null,\n) {\n  const {\n    onMouseEnter: onMouseEnterProp,\n    onMouseMove: onMouseMoveProp,\n    onMouseLeave: onMouseLeaveProp,\n    onClick: onClickProp,\n    onFocus: onFocusProp,\n    isDisabled,\n    isFocusable,\n    closeOnSelect,\n    type: typeProp,\n    ...htmlProps\n  } = props\n\n  const menu = useMenuContext()\n\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    closeOnSelect: menuCloseOnSelect,\n    onClose,\n    menuRef,\n    isOpen,\n    menuId,\n    rafId,\n  } = menu\n\n  const ref = useRef<HTMLDivElement>(null)\n  const id = `${menuId}-menuitem-${useId()}`\n\n  /**\n   * Register the menuitem's node into the domContext\n   */\n  const { index, register } = useMenuDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const onMouseEnter = useCallback(\n    (event: any) => {\n      onMouseEnterProp?.(event)\n      if (isDisabled) return\n      setFocusedIndex(index)\n    },\n    [setFocusedIndex, index, isDisabled, onMouseEnterProp],\n  )\n\n  const onMouseMove = useCallback(\n    (event: any) => {\n      onMouseMoveProp?.(event)\n      if (ref.current && !isActiveElement(ref.current)) {\n        onMouseEnter(event)\n      }\n    },\n    [onMouseEnter, onMouseMoveProp],\n  )\n\n  const onMouseLeave = useCallback(\n    (event: any) => {\n      onMouseLeaveProp?.(event)\n      if (isDisabled) return\n      setFocusedIndex(-1)\n    },\n    [setFocusedIndex, isDisabled, onMouseLeaveProp],\n  )\n\n  const onClick = useCallback(\n    (event: React.MouseEvent) => {\n      onClickProp?.(event)\n      if (!isTargetMenuItem(event.currentTarget)) return\n      /**\n       * Close menu and parent menus, allowing the MenuItem\n       * to override its parent menu's `closeOnSelect` prop.\n       */\n      if (closeOnSelect ?? menuCloseOnSelect) {\n        onClose()\n      }\n    },\n    [onClose, onClickProp, menuCloseOnSelect, closeOnSelect],\n  )\n\n  const onFocus = useCallback(\n    (event: React.FocusEvent) => {\n      onFocusProp?.(event)\n      setFocusedIndex(index)\n    },\n    [setFocusedIndex, onFocusProp, index],\n  )\n\n  const isFocused = index === focusedIndex\n\n  const trulyDisabled = isDisabled && !isFocusable\n\n  useUpdateEffect(() => {\n    if (!isOpen) return\n    if (isFocused && !trulyDisabled && ref.current) {\n      // Cancel any pending animations\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current)\n      }\n      rafId.current = requestAnimationFrame(() => {\n        ref.current?.focus({ preventScroll: true })\n        rafId.current = null\n      })\n    } else if (menuRef.current && !isActiveElement(menuRef.current)) {\n      menuRef.current.focus({ preventScroll: true })\n    }\n\n    return () => {\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current)\n      }\n    }\n  }, [isFocused, trulyDisabled, menuRef, isOpen])\n\n  const clickableProps = useClickable({\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    ref: mergeRefs(register, ref, externalRef),\n    isDisabled,\n    isFocusable,\n  })\n\n  return {\n    ...htmlProps,\n    ...clickableProps,\n    type: typeProp ?? (clickableProps as any).type,\n    id,\n    role: \"menuitem\",\n    tabIndex: isFocused ? 0 : -1,\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuOption: Composes useMenuItem to provide a selectable/checkable menu item\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuOptionOptions {\n  value?: string\n  isChecked?: boolean\n  type?: \"radio\" | \"checkbox\"\n  children?: React.ReactNode\n}\n\nexport interface UseMenuOptionProps\n  extends Omit<UseMenuItemProps, \"type\">,\n    UseMenuOptionOptions {}\n\nexport function useMenuOption(\n  props: UseMenuOptionProps = {},\n  ref: React.Ref<any> = null,\n) {\n  const { type = \"radio\", isChecked, ...rest } = props\n  const ownProps = useMenuItem(rest, ref)\n  return {\n    ...ownProps,\n    role: `menuitem${type}`,\n    \"aria-checked\": isChecked as React.AriaAttributes[\"aria-checked\"],\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuOptionGroup: Manages the state of multiple selectable menuitem or menu option\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuOptionGroupProps {\n  value?: string | string[]\n  defaultValue?: string | string[]\n  type?: \"radio\" | \"checkbox\"\n  onChange?: (value: string | string[]) => void\n  children?: React.ReactNode\n}\n\nexport function useMenuOptionGroup(props: UseMenuOptionGroupProps = {}) {\n  const {\n    children,\n    type = \"radio\",\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp,\n    ...htmlProps\n  } = props\n\n  const isRadio = type === \"radio\"\n\n  const fallback = isRadio ? \"\" : []\n\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue ?? fallback,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n\n  const onChange = useCallback(\n    (selectedValue: string) => {\n      if (type === \"radio\" && typeof value === \"string\") {\n        setValue(selectedValue)\n      }\n\n      if (type === \"checkbox\" && Array.isArray(value)) {\n        const nextValue = value.includes(selectedValue)\n          ? value.filter((item) => item !== selectedValue)\n          : value.concat(selectedValue)\n\n        setValue(nextValue)\n      }\n    },\n    [value, setValue, type],\n  )\n\n  const validChildren = getValidChildren(children)\n\n  const clones = validChildren.map((child) => {\n    /**\n     * We've added an internal `id` to each `MenuItemOption`,\n     * let's use that for type-checking.\n     *\n     * We can't rely on displayName or the element's type since\n     * they can be changed by the user.\n     */\n    if ((child.type as any).id !== \"MenuItemOption\") return child\n\n    const onClick = (event: MouseEvent) => {\n      onChange(child.props.value)\n      child.props.onClick?.(event)\n    }\n\n    const isChecked =\n      type === \"radio\"\n        ? child.props.value === value\n        : value.includes(child.props.value)\n\n    return cloneElement(child, {\n      type,\n      onClick,\n      isChecked,\n    })\n  })\n\n  return {\n    ...htmlProps,\n    children: clones,\n  }\n}\n\nexport function useMenuState() {\n  const { isOpen, onClose } = useMenuContext()\n  return { isOpen, onClose }\n}\n\nfunction isHTMLElement(el: any): el is HTMLElement {\n  if (!isElement(el)) return false\n  const win = el.ownerDocument.defaultView ?? window\n  return el instanceof win.HTMLElement\n}\n\nfunction isElement(el: any): el is Element {\n  return (\n    el != null &&\n    typeof el == \"object\" &&\n    \"nodeType\" in el &&\n    el.nodeType === Node.ELEMENT_NODE\n  )\n}\n"]},"metadata":{},"sourceType":"module"}