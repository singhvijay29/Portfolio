{"ast":null,"code":"'use client';\n\nvar __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n}; // src/pan-event.ts\n\n\nimport { addPointerEvent, getEventPoint, isMultiTouchEvent } from \"@chakra-ui/event-utils\";\nimport sync, { cancelSync, getFrameData } from \"framesync\";\nvar PanEvent = class {\n  constructor(event, handlers, threshold) {\n    /**\n     * We use this to keep track of the `x` and `y` pan session history\n     * as the pan event happens. It helps to calculate the `offset` and `delta`\n     */\n    __publicField(this, \"history\", []); // The pointer event that started the pan session\n\n\n    __publicField(this, \"startEvent\", null); // The current pointer event for the pan session\n\n\n    __publicField(this, \"lastEvent\", null); // The current pointer event info for the pan session\n\n\n    __publicField(this, \"lastEventInfo\", null);\n\n    __publicField(this, \"handlers\", {});\n\n    __publicField(this, \"removeListeners\", () => {});\n    /**\n     * Minimal pan distance required before recognizing the pan.\n     * @default \"3px\"\n     */\n\n\n    __publicField(this, \"threshold\", 3);\n\n    __publicField(this, \"win\");\n\n    __publicField(this, \"updatePoint\", () => {\n      if (!(this.lastEvent && this.lastEventInfo)) return;\n      const info = getPanInfo(this.lastEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= this.threshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        timestamp\n      } = getFrameData();\n      this.history.push({ ...info.point,\n        timestamp\n      });\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n\n      if (!isPanStarted) {\n        onStart == null ? void 0 : onStart(this.lastEvent, info);\n        this.startEvent = this.lastEvent;\n      }\n\n      onMove == null ? void 0 : onMove(this.lastEvent, info);\n    });\n\n    __publicField(this, \"onPointerMove\", (event, info) => {\n      this.lastEvent = event;\n      this.lastEventInfo = info;\n      sync.update(this.updatePoint, true);\n    });\n\n    __publicField(this, \"onPointerUp\", (event, info) => {\n      const panInfo = getPanInfo(info, this.history);\n      const {\n        onEnd,\n        onSessionEnd\n      } = this.handlers;\n      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);\n      this.end();\n      if (!onEnd || !this.startEvent) return;\n      onEnd == null ? void 0 : onEnd(event, panInfo);\n    });\n\n    var _a;\n\n    this.win = (_a = event.view) != null ? _a : window;\n    if (isMultiTouchEvent(event)) return;\n    this.handlers = handlers;\n\n    if (threshold) {\n      this.threshold = threshold;\n    }\n\n    event.stopPropagation();\n    event.preventDefault();\n    const info = {\n      point: getEventPoint(event)\n    };\n    const {\n      timestamp\n    } = getFrameData();\n    this.history = [{ ...info.point,\n      timestamp\n    }];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart == null ? void 0 : onSessionStart(event, getPanInfo(info, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.win, \"pointermove\", this.onPointerMove), addPointerEvent(this.win, \"pointerup\", this.onPointerUp), addPointerEvent(this.win, \"pointercancel\", this.onPointerUp));\n  }\n\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n\n  end() {\n    var _a;\n\n    (_a = this.removeListeners) == null ? void 0 : _a.call(this);\n    cancelSync.update(this.updatePoint);\n  }\n\n};\n\nfunction subtract(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction getPanInfo(info, history) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nvar toMilliseconds = v => v * 1e3;\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = history[history.length - 1];\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nfunction pipe() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return v => fns.reduce((a, b) => b(a), v);\n}\n\nfunction distance1D(a, b) {\n  return Math.abs(a - b);\n}\n\nfunction isPoint(point) {\n  return \"x\" in point && \"y\" in point;\n}\n\nfunction distance(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b);\n  }\n\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n  }\n\n  return 0;\n}\n\nexport { PanEvent, distance };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/react-use-pan-event/src/pan-event.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  addPointerEvent,\n  getEventPoint,\n  isMultiTouchEvent,\n} from \"@chakra-ui/event-utils\"\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport {\n  AnyPointerEvent,\n  PanEventHandlers,\n  PanEventHistory,\n  Point,\n  PointerEventInfo,\n  TimestampedPoint,\n} from \"./types\"\n\n/**\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport class PanEvent {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  private history: PanEventHistory = []\n\n  // The pointer event that started the pan session\n  private startEvent: AnyPointerEvent | null = null\n\n  // The current pointer event for the pan session\n  private lastEvent: AnyPointerEvent | null = null\n\n  // The current pointer event info for the pan session\n  private lastEventInfo: PointerEventInfo | null = null\n\n  private handlers: Partial<PanEventHandlers> = {}\n\n  private removeListeners: Function = () => {}\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  private threshold = 3\n\n  private win: typeof globalThis\n\n  constructor(\n    event: AnyPointerEvent,\n    handlers: Partial<PanEventHandlers>,\n    threshold?: number,\n  ) {\n    this.win = (event.view ?? window) as typeof globalThis.window\n\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(event)) return\n\n    this.handlers = handlers\n\n    if (threshold) {\n      this.threshold = threshold\n    }\n\n    // stop default browser behavior\n    event.stopPropagation()\n    event.preventDefault()\n\n    // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n    const info = { point: getEventPoint(event) }\n    const { timestamp } = getFrameData()\n    this.history = [{ ...info.point, timestamp }]\n\n    // notify pan session start\n    const { onSessionStart } = handlers\n    onSessionStart?.(event, getPanInfo(info, this.history))\n\n    // attach event listeners and return a single function to remove them all\n    this.removeListeners = pipe(\n      addPointerEvent(this.win, \"pointermove\", this.onPointerMove),\n      addPointerEvent(this.win, \"pointerup\", this.onPointerUp),\n      addPointerEvent(this.win, \"pointercancel\", this.onPointerUp),\n    )\n  }\n\n  private updatePoint = () => {\n    if (!(this.lastEvent && this.lastEventInfo)) return\n\n    const info = getPanInfo(this.lastEventInfo, this.history)\n\n    const isPanStarted = this.startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= this.threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n    this.history.push({ ...info.point, timestamp })\n\n    const { onStart, onMove } = this.handlers\n\n    if (!isPanStarted) {\n      onStart?.(this.lastEvent, info)\n      this.startEvent = this.lastEvent\n    }\n\n    onMove?.(this.lastEvent, info)\n  }\n\n  private onPointerMove = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.lastEvent = event\n    this.lastEventInfo = info\n\n    // Throttle mouse move event to once per frame\n    sync.update(this.updatePoint, true)\n  }\n\n  private onPointerUp = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    // notify pan session ended\n    const panInfo = getPanInfo(info, this.history)\n    const { onEnd, onSessionEnd } = this.handlers\n\n    onSessionEnd?.(event, panInfo)\n    this.end()\n\n    // if panning never started, no need to call `onEnd`\n    // panning requires a pointermove of at least 3px\n    if (!onEnd || !this.startEvent) return\n\n    onEnd?.(event, panInfo)\n  }\n\n  updateHandlers(handlers: Partial<PanEventHandlers>) {\n    this.handlers = handlers\n  }\n\n  end() {\n    this.removeListeners?.()\n    cancelSync.update(this.updatePoint)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Utilities\n * -----------------------------------------------------------------------------*/\n\nfunction subtract(a: Point, b: Point) {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction getPanInfo(info: PointerEventInfo, history: PanEventHistory) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1),\n  }\n}\n\nconst toMilliseconds = (v: number) => v * 1000\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) {\n    return { x: 0, y: 0 }\n  }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = history[history.length - 1]\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 }\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n  if (time === 0) {\n    return { x: 0, y: 0 }\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0\n  }\n\n  return currentVelocity\n}\n\nfunction pipe<R>(...fns: Array<(a: R) => R>) {\n  return (v: R) => fns.reduce((a, b) => b(a), v)\n}\n\nfunction distance1D(a: number, b: number) {\n  return Math.abs(a - b)\n}\n\nfunction isPoint(point: any): point is { x: number; y: number } {\n  return \"x\" in point && \"y\" in point\n}\n\nexport function distance<P extends Point | number>(a: P, b: P) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b)\n  }\n\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x)\n    const yDelta = distance1D(a.y, b.y)\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n  }\n\n  return 0\n}\n"]},"metadata":{},"sourceType":"module"}