{"ast":null,"code":"class Queue {\n  constructor() {\n    this.order = [];\n    this.scheduled = new Set();\n  }\n\n  add(process) {\n    if (!this.scheduled.has(process)) {\n      this.scheduled.add(process);\n      this.order.push(process);\n      return true;\n    }\n  }\n\n  remove(process) {\n    const index = this.order.indexOf(process);\n\n    if (index !== -1) {\n      this.order.splice(index, 1);\n      this.scheduled.delete(process);\n    }\n  }\n\n  clear() {\n    this.order.length = 0;\n    this.scheduled.clear();\n  }\n\n}\n\nfunction createRenderStep(runNextFrame) {\n  /**\n   * We create and reuse two queues, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  let thisFrame = new Queue();\n  let nextFrame = new Queue();\n  let numToRun = 0;\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n\n  const toKeepAlive = new WeakSet();\n  const step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: function (callback) {\n      let keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n\n      if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n        // If we're adding it to the currently running queue, update its measured size\n        numToRun = thisFrame.order.length;\n      }\n\n      return callback;\n    },\n\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: callback => {\n      nextFrame.remove(callback);\n      toKeepAlive.delete(callback);\n    },\n\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: frameData => {\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame]; // Clear the next frame queue\n\n      nextFrame.clear(); // Execute this frame\n\n      numToRun = thisFrame.order.length;\n\n      if (numToRun) {\n        for (let i = 0; i < numToRun; i++) {\n          const callback = thisFrame.order[i];\n\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n\n          callback(frameData);\n        }\n      }\n\n      isProcessing = false;\n\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\nexport { createRenderStep };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"names":["Queue","constructor","order","scheduled","Set","add","process","has","push","remove","index","indexOf","splice","delete","clear","length","createRenderStep","runNextFrame","thisFrame","nextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","callback","keepAlive","immediate","addToCurrentFrame","queue","cancel","frameData","i"],"mappings":"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","sourcesContent":["class Queue {\n    constructor() {\n        this.order = [];\n        this.scheduled = new Set();\n    }\n    add(process) {\n        if (!this.scheduled.has(process)) {\n            this.scheduled.add(process);\n            this.order.push(process);\n            return true;\n        }\n    }\n    remove(process) {\n        const index = this.order.indexOf(process);\n        if (index !== -1) {\n            this.order.splice(index, 1);\n            this.scheduled.delete(process);\n        }\n    }\n    clear() {\n        this.order.length = 0;\n        this.scheduled.clear();\n    }\n}\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Queue();\n    let nextFrame = new Queue();\n    let numToRun = 0;\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n                // If we're adding it to the currently running queue, update its measured size\n                numToRun = thisFrame.order.length;\n            }\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.remove(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Clear the next frame queue\n            nextFrame.clear();\n            // Execute this frame\n            numToRun = thisFrame.order.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = thisFrame.order[i];\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                    callback(frameData);\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"]},"metadata":{},"sourceType":"module"}