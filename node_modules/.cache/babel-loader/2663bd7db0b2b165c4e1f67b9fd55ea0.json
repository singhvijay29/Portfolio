{"ast":null,"code":"'use client';\n\nimport { ariaAttr, callAllHandlers, dataAttr } from \"./chunk-DX64QB22.mjs\";\nimport { getIsReversed, getStyles } from \"./chunk-E23N4XEN.mjs\"; // src/use-slider.ts\n\nimport { usePanEvent } from \"@chakra-ui/react-use-pan-event\";\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { useSize } from \"@chakra-ui/react-use-size\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { useLatestRef } from \"@chakra-ui/react-use-latest-ref\";\nimport { clampValue, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/number-utils\";\nimport { useCallback, useMemo, useRef, useId, useState } from \"react\";\n\nfunction useSlider(props) {\n  var _a;\n\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props;\n  const onChangeStart = useCallbackRef(onChangeStartProp);\n  const onChangeEnd = useCallbackRef(onChangeEndProp);\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation\n  });\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),\n    onChange\n  });\n  const [isDragging, setDragging] = useState(false);\n  const [isFocused, setFocused] = useState(false);\n  const isInteractive = !(isDisabled || isReadOnly);\n  const tenSteps = (max - min) / 10;\n  const oneStep = step || (max - min) / 100;\n  const value = clampValue(computedValue, min, max);\n  const reversedValue = max - value + min;\n  const trackValue = isReversed ? reversedValue : value;\n  const thumbPercent = valueToPercent(trackValue, min, max);\n  const isVertical = orientation === \"vertical\";\n  const stateRef = useLatestRef({\n    min,\n    max,\n    step,\n    isDisabled,\n    value,\n    isInteractive,\n    isReversed,\n    isVertical,\n    eventSource: null,\n    focusThumbOnChange,\n    orientation\n  });\n  const trackRef = useRef(null);\n  const thumbRef = useRef(null);\n  const rootRef = useRef(null);\n  const reactId = useId();\n  const uuid = idProp != null ? idProp : reactId;\n  const [thumbId, trackId] = [`slider-thumb-${uuid}`, `slider-track-${uuid}`];\n  const getValueFromPointer = useCallback(event => {\n    var _a2, _b;\n\n    if (!trackRef.current) return;\n    const state2 = stateRef.current;\n    state2.eventSource = \"pointer\";\n    const trackRect = trackRef.current.getBoundingClientRect();\n    const {\n      clientX,\n      clientY\n    } = (_b = (_a2 = event.touches) == null ? void 0 : _a2[0]) != null ? _b : event;\n    const diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;\n    const length = isVertical ? trackRect.height : trackRect.width;\n    let percent = diff / length;\n\n    if (isReversed) {\n      percent = 1 - percent;\n    }\n\n    let nextValue = percentToValue(percent, state2.min, state2.max);\n\n    if (state2.step) {\n      nextValue = parseFloat(roundValueToStep(nextValue, state2.min, state2.step));\n    }\n\n    nextValue = clampValue(nextValue, state2.min, state2.max);\n    return nextValue;\n  }, [isVertical, isReversed, stateRef]);\n  const constrain = useCallback(value2 => {\n    const state2 = stateRef.current;\n    if (!state2.isInteractive) return;\n    value2 = parseFloat(roundValueToStep(value2, state2.min, oneStep));\n    value2 = clampValue(value2, state2.min, state2.max);\n    setValue(value2);\n  }, [oneStep, setValue, stateRef]);\n  const actions = useMemo(() => ({\n    stepUp() {\n      let step2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : oneStep;\n      const next = isReversed ? value - step2 : value + step2;\n      constrain(next);\n    },\n\n    stepDown() {\n      let step2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : oneStep;\n      const next = isReversed ? value + step2 : value - step2;\n      constrain(next);\n    },\n\n    reset() {\n      constrain(defaultValue || 0);\n    },\n\n    stepTo(value2) {\n      constrain(value2);\n    }\n\n  }), [constrain, isReversed, value, oneStep, defaultValue]);\n  const onKeyDown = useCallback(event => {\n    const state2 = stateRef.current;\n    const keyMap = {\n      ArrowRight: () => actions.stepUp(),\n      ArrowUp: () => actions.stepUp(),\n      ArrowLeft: () => actions.stepDown(),\n      ArrowDown: () => actions.stepDown(),\n      PageUp: () => actions.stepUp(tenSteps),\n      PageDown: () => actions.stepDown(tenSteps),\n      Home: () => constrain(state2.min),\n      End: () => constrain(state2.max)\n    };\n    const action = keyMap[event.key];\n\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      state2.eventSource = \"keyboard\";\n    }\n  }, [actions, constrain, tenSteps, stateRef]);\n  const valueText = (_a = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _a : ariaValueText;\n  const thumbSize = useSize(thumbRef);\n  const {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle\n  } = useMemo(() => {\n    const state2 = stateRef.current;\n    const thumbRect = thumbSize != null ? thumbSize : {\n      width: 0,\n      height: 0\n    };\n    return getStyles({\n      isReversed,\n      orientation: state2.orientation,\n      thumbRects: [thumbRect],\n      thumbPercents: [thumbPercent]\n    });\n  }, [isReversed, thumbSize, thumbPercent, stateRef]);\n  const focusThumb = useCallback(() => {\n    const state2 = stateRef.current;\n\n    if (state2.focusThumbOnChange) {\n      setTimeout(() => {\n        var _a2;\n\n        return (_a2 = thumbRef.current) == null ? void 0 : _a2.focus();\n      });\n    }\n  }, [stateRef]);\n  useUpdateEffect(() => {\n    const state2 = stateRef.current;\n    focusThumb();\n\n    if (state2.eventSource === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(state2.value);\n    }\n  }, [value, onChangeEnd]);\n\n  function setValueFromPointer(event) {\n    const nextValue = getValueFromPointer(event);\n\n    if (nextValue != null && nextValue !== stateRef.current.value) {\n      setValue(nextValue);\n    }\n  }\n\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      const state2 = stateRef.current;\n      if (!state2.isInteractive) return;\n      setDragging(true);\n      focusThumb();\n      setValueFromPointer(event);\n      onChangeStart == null ? void 0 : onChangeStart(state2.value);\n    },\n\n    onPanSessionEnd() {\n      const state2 = stateRef.current;\n      if (!state2.isInteractive) return;\n      setDragging(false);\n      onChangeEnd == null ? void 0 : onChangeEnd(state2.value);\n    },\n\n    onPan(event) {\n      const state2 = stateRef.current;\n      if (!state2.isInteractive) return;\n      setValueFromPointer(event);\n    }\n\n  });\n  const getRootProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ...htmlProps,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: { ...props2.style,\n        ...rootStyle\n      }\n    };\n  }, [htmlProps, isDisabled, isFocused, rootStyle]);\n  const getTrackProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: { ...props2.style,\n        ...trackStyle\n      }\n    };\n  }, [isDisabled, trackId, trackStyle]);\n  const getInnerTrackProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ref,\n      style: { ...props2.style,\n        ...innerTrackStyle\n      }\n    };\n  }, [innerTrackStyle]);\n  const getThumbProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : void 0,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? void 0 : ariaLabelledBy,\n      style: { ...props2.style,\n        ...getThumbStyle(0)\n      },\n      onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props2.onFocus, () => setFocused(true)),\n      onBlur: callAllHandlers(props2.onBlur, () => setFocused(false))\n    };\n  }, [isInteractive, thumbId, isDragging, valueText, min, max, value, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown]);\n  const getMarkerProps = useCallback(function (props2) {\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const isInRange = !(props2.value < min || props2.value > max);\n    const isHighlighted = value >= props2.value;\n    const markerPercent = valueToPercent(props2.value, min, max);\n    const markerStyle = {\n      position: \"absolute\",\n      pointerEvents: \"none\",\n      ...orient({\n        orientation,\n        vertical: {\n          bottom: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`\n        },\n        horizontal: {\n          left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`\n        }\n      })\n    };\n    return { ...props2,\n      ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: { ...props2.style,\n        ...markerStyle\n      }\n    };\n  }, [isDisabled, isReversed, max, min, orientation, value]);\n  const getInputProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ref,\n      type: \"hidden\",\n      value,\n      name\n    };\n  }, [name, value]);\n  const state = {\n    value,\n    isFocused,\n    isDragging\n  };\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps\n  };\n}\n\nfunction orient(options) {\n  const {\n    orientation,\n    vertical,\n    horizontal\n  } = options;\n  return orientation === \"vertical\" ? vertical : horizontal;\n}\n\nfunction getDefaultValue(min, max) {\n  return max < min ? min : min + (max - min) / 2;\n}\n\nexport { useSlider };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/slider/src/use-slider.ts"],"names":["state","value","step","props"],"mappings":"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","sourcesContent":["import { usePanEvent } from \"@chakra-ui/react-use-pan-event\"\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { useSize } from \"@chakra-ui/react-use-size\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { useLatestRef } from \"@chakra-ui/react-use-latest-ref\"\nimport type { PropGetter, RequiredPropGetter } from \"@chakra-ui/react-types\"\nimport {\n  clampValue,\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/number-utils\"\nimport { ariaAttr, callAllHandlers, dataAttr } from \"@chakra-ui/utils\"\nimport { useCallback, useMemo, useRef, useId, useState } from \"react\"\nimport { getIsReversed, getStyles } from \"./slider-utils\"\n\nexport interface UseSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number\n  /**\n   * Orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number): void\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number): void\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string\n  /**\n   * If `true`, the slider will be disabled\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   * @default false\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string\n  /**\n   * The writing mode\n   * @default \"ltr\"\n   */\n  direction?: \"ltr\" | \"rtl\"\n}\n\nexport interface SliderState {\n  value: number\n  isFocused: boolean\n  isDragging: boolean\n}\n\nexport interface SliderActions {\n  stepUp(step?: number): void\n  stepDown(step?: number): void\n  reset(): void\n  stepTo(value: number): void\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/slider/\n */\nexport function useSlider(props: UseSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? getDefaultValue(min, max),\n    onChange,\n  })\n\n  const [isDragging, setDragging] = useState(false)\n  const [isFocused, setFocused] = useState(false)\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n  const value = clampValue(computedValue, min, max)\n  const reversedValue = max - value + min\n  const trackValue = isReversed ? reversedValue : value\n  const thumbPercent = valueToPercent(trackValue, min, max)\n\n  const isVertical = orientation === \"vertical\"\n\n  const stateRef = useLatestRef({\n    min,\n    max,\n    step,\n    isDisabled,\n    value,\n    isInteractive,\n    isReversed,\n    isVertical,\n    eventSource: null as \"pointer\" | \"keyboard\" | null,\n    focusThumbOnChange,\n    orientation,\n  })\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<HTMLElement>(null)\n  const thumbRef = useRef<HTMLElement>(null)\n  const rootRef = useRef<HTMLElement>(null)\n\n  /**\n   * Generate unique ids for component parts\n   */\n  const reactId = useId()\n  const uuid = idProp ?? reactId\n  const [thumbId, trackId] = [`slider-thumb-${uuid}`, `slider-track-${uuid}`]\n\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  const getValueFromPointer = useCallback(\n    (event: any) => {\n      if (!trackRef.current) return\n\n      const state = stateRef.current\n      state.eventSource = \"pointer\"\n\n      const trackRect = trackRef.current.getBoundingClientRect()\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical\n        ? trackRect.bottom - clientY\n        : clientX - trackRect.left\n\n      const length = isVertical ? trackRect.height : trackRect.width\n      let percent = diff / length\n\n      if (isReversed) {\n        percent = 1 - percent\n      }\n\n      let nextValue = percentToValue(percent, state.min, state.max)\n\n      if (state.step) {\n        nextValue = parseFloat(\n          roundValueToStep(nextValue, state.min, state.step),\n        )\n      }\n\n      nextValue = clampValue(nextValue, state.min, state.max)\n\n      return nextValue\n    },\n    [isVertical, isReversed, stateRef],\n  )\n\n  const constrain = useCallback(\n    (value: number) => {\n      const state = stateRef.current\n      if (!state.isInteractive) return\n      value = parseFloat(roundValueToStep(value, state.min, oneStep))\n      value = clampValue(value, state.min, state.max)\n      setValue(value)\n    },\n    [oneStep, setValue, stateRef],\n  )\n\n  const actions: SliderActions = useMemo(\n    () => ({\n      stepUp(step = oneStep) {\n        const next = isReversed ? value - step : value + step\n        constrain(next)\n      },\n      stepDown(step = oneStep) {\n        const next = isReversed ? value + step : value - step\n        constrain(next)\n      },\n      reset() {\n        constrain(defaultValue || 0)\n      },\n      stepTo(value: number) {\n        constrain(value)\n      },\n    }),\n    [constrain, isReversed, value, oneStep, defaultValue],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const state = stateRef.current\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        ArrowRight: () => actions.stepUp(),\n        ArrowUp: () => actions.stepUp(),\n        ArrowLeft: () => actions.stepDown(),\n        ArrowDown: () => actions.stepDown(),\n        PageUp: () => actions.stepUp(tenSteps),\n        PageDown: () => actions.stepDown(tenSteps),\n        Home: () => constrain(state.min),\n        End: () => constrain(state.max),\n      }\n\n      const action = keyMap[event.key]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        state.eventSource = \"keyboard\"\n      }\n    },\n    [actions, constrain, tenSteps, stateRef],\n  )\n\n  /**\n   * ARIA (Optional): To define a human-readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n  const valueText = getAriaValueText?.(value) ?? ariaValueText\n\n  /**\n   * Measure the dimensions of the thumb, so\n   * we can center it within the track properly\n   */\n  const thumbSize = useSize(thumbRef)\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } =\n    useMemo(() => {\n      const state = stateRef.current\n\n      const thumbRect = thumbSize ?? { width: 0, height: 0 }\n      return getStyles({\n        isReversed,\n        orientation: state.orientation,\n        thumbRects: [thumbRect],\n        thumbPercents: [thumbPercent],\n      })\n    }, [isReversed, thumbSize, thumbPercent, stateRef])\n\n  const focusThumb = useCallback(() => {\n    const state = stateRef.current\n    if (state.focusThumbOnChange) {\n      setTimeout(() => thumbRef.current?.focus())\n    }\n  }, [stateRef])\n\n  useUpdateEffect(() => {\n    const state = stateRef.current\n    focusThumb()\n    if (state.eventSource === \"keyboard\") {\n      onChangeEnd?.(state.value)\n    }\n  }, [value, onChangeEnd])\n\n  function setValueFromPointer(event: MouseEvent | TouchEvent | PointerEvent) {\n    const nextValue = getValueFromPointer(event)\n    if (nextValue != null && nextValue !== stateRef.current.value) {\n      setValue(nextValue)\n    }\n  }\n\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      const state = stateRef.current\n      if (!state.isInteractive) return\n      setDragging(true)\n      focusThumb()\n      setValueFromPointer(event)\n      onChangeStart?.(state.value)\n    },\n    onPanSessionEnd() {\n      const state = stateRef.current\n      if (!state.isInteractive) return\n      setDragging(false)\n      onChangeEnd?.(state.value)\n    },\n    onPan(event) {\n      const state = stateRef.current\n      if (!state.isInteractive) return\n      setValueFromPointer(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ...htmlProps,\n        ref: mergeRefs(ref, rootRef),\n        tabIndex: -1,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"data-focused\": dataAttr(isFocused),\n        style: {\n          ...props.style,\n          ...rootStyle,\n        },\n      }\n    },\n    [htmlProps, isDisabled, isFocused, rootStyle],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref: mergeRefs(ref, trackRef),\n        id: trackId,\n        \"data-disabled\": dataAttr(isDisabled),\n        style: {\n          ...props.style,\n          ...trackStyle,\n        },\n      }\n    },\n    [isDisabled, trackId, trackStyle],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        style: {\n          ...props.style,\n          ...innerTrackStyle,\n        },\n      }\n    },\n    [innerTrackStyle],\n  )\n\n  const getThumbProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref: mergeRefs(ref, thumbRef),\n        role: \"slider\",\n        tabIndex: isInteractive ? 0 : undefined,\n        id: thumbId,\n        \"data-active\": dataAttr(isDragging),\n        \"aria-valuetext\": valueText,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": value,\n        \"aria-orientation\": orientation,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"aria-readonly\": ariaAttr(isReadOnly),\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n        style: {\n          ...props.style,\n          ...getThumbStyle(0),\n        },\n        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(props.onFocus, () => setFocused(true)),\n        onBlur: callAllHandlers(props.onBlur, () => setFocused(false)),\n      }\n    },\n    [\n      isInteractive,\n      thumbId,\n      isDragging,\n      valueText,\n      min,\n      max,\n      value,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n    ],\n  )\n\n  const getMarkerProps: RequiredPropGetter<{ value: number }> = useCallback(\n    (props, ref = null) => {\n      const isInRange = !(props.value < min || props.value > max)\n      const isHighlighted = value >= props.value\n      const markerPercent = valueToPercent(props.value, min, max)\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation: orientation,\n          vertical: {\n            bottom: isReversed\n              ? `${100 - markerPercent}%`\n              : `${markerPercent}%`,\n          },\n          horizontal: {\n            left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n          },\n        }),\n      }\n\n      return {\n        ...props,\n        ref,\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value],\n  )\n\n  const getInputProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        type: \"hidden\",\n        value,\n        name,\n      }\n    },\n    [name, value],\n  )\n\n  const state: SliderState = { value, isFocused, isDragging }\n\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n\nfunction orient(options: {\n  orientation: UseSliderProps[\"orientation\"]\n  vertical: React.CSSProperties\n  horizontal: React.CSSProperties\n}) {\n  const { orientation, vertical, horizontal } = options\n  return orientation === \"vertical\" ? vertical : horizontal\n}\n\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\nfunction getDefaultValue(min: number, max: number) {\n  return max < min ? min : min + (max - min) / 2\n}\n"]},"metadata":{},"sourceType":"module"}