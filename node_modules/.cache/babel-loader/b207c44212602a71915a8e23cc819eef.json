{"ast":null,"code":"import { toArray } from './array';\nimport { isAutoFocusAllowedCached, isVisibleCached, notHiddenInput } from './is';\nimport { orderByTabIndex } from './tabOrder';\nimport { getFocusables, getParentAutofocusables } from './tabUtils';\n/**\n * given list of focusable elements keeps the ones user can interact with\n * @param nodes\n * @param visibilityCache\n */\n\nexport var filterFocusable = function (nodes, visibilityCache) {\n  return toArray(nodes).filter(function (node) {\n    return isVisibleCached(visibilityCache, node);\n  }).filter(function (node) {\n    return notHiddenInput(node);\n  });\n};\nexport var filterAutoFocusable = function (nodes, cache) {\n  if (cache === void 0) {\n    cache = new Map();\n  }\n\n  return toArray(nodes).filter(function (node) {\n    return isAutoFocusAllowedCached(cache, node);\n  });\n};\n/**\n * !__WARNING__! Low level API.\n * @returns all tabbable nodes\n *\n * @see {@link getFocusableNodes} to get any focusable element\n *\n * @param topNodes - array of top level HTMLElements to search inside\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\n */\n\nexport var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {\n  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);\n};\n/**\n * !__WARNING__! Low level API.\n *\n * @returns anything \"focusable\", not only tabbable. The difference is in `tabIndex=-1`\n * (without guards, as long as they are not expected to be ever focused)\n *\n * @see {@link getTabbableNodes} to get only tabble nodes element\n *\n * @param topNodes - array of top level HTMLElements to search inside\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\n */\n\nexport var getFocusableNodes = function (topNodes, visibilityCache) {\n  return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);\n};\n/**\n * return list of nodes which are expected to be auto-focused\n * @param topNode\n * @param visibilityCache\n */\n\nexport var parentAutofocusables = function (topNode, visibilityCache) {\n  return filterFocusable(getParentAutofocusables(topNode), visibilityCache);\n};\n/*\n * Determines if element is contained in scope, including nested shadow DOMs\n */\n\nexport var contains = function (scope, element) {\n  if (scope.shadowRoot) {\n    return contains(scope.shadowRoot, element);\n  } else {\n    if (Object.getPrototypeOf(scope).contains !== undefined && Object.getPrototypeOf(scope).contains.call(scope, element)) {\n      return true;\n    }\n\n    return toArray(scope.children).some(function (child) {\n      var _a;\n\n      if (child instanceof HTMLIFrameElement) {\n        var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;\n\n        if (iframeBody) {\n          return contains(iframeBody, element);\n        }\n\n        return false;\n      }\n\n      return contains(child, element);\n    });\n  }\n};","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/focus-lock/dist/es2015/utils/DOMutils.js"],"names":["toArray","isAutoFocusAllowedCached","isVisibleCached","notHiddenInput","orderByTabIndex","getFocusables","getParentAutofocusables","filterFocusable","nodes","visibilityCache","filter","node","filterAutoFocusable","cache","Map","getTabbableNodes","topNodes","withGuards","getFocusableNodes","parentAutofocusables","topNode","contains","scope","element","shadowRoot","Object","getPrototypeOf","undefined","call","children","some","child","_a","HTMLIFrameElement","iframeBody","contentDocument","body"],"mappings":"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","sourcesContent":["import { toArray } from './array';\nimport { isAutoFocusAllowedCached, isVisibleCached, notHiddenInput } from './is';\nimport { orderByTabIndex } from './tabOrder';\nimport { getFocusables, getParentAutofocusables } from './tabUtils';\n/**\n * given list of focusable elements keeps the ones user can interact with\n * @param nodes\n * @param visibilityCache\n */\nexport var filterFocusable = function (nodes, visibilityCache) {\n    return toArray(nodes)\n        .filter(function (node) { return isVisibleCached(visibilityCache, node); })\n        .filter(function (node) { return notHiddenInput(node); });\n};\nexport var filterAutoFocusable = function (nodes, cache) {\n    if (cache === void 0) { cache = new Map(); }\n    return toArray(nodes).filter(function (node) { return isAutoFocusAllowedCached(cache, node); });\n};\n/**\n * !__WARNING__! Low level API.\n * @returns all tabbable nodes\n *\n * @see {@link getFocusableNodes} to get any focusable element\n *\n * @param topNodes - array of top level HTMLElements to search inside\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\n */\nexport var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {\n    return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);\n};\n/**\n * !__WARNING__! Low level API.\n *\n * @returns anything \"focusable\", not only tabbable. The difference is in `tabIndex=-1`\n * (without guards, as long as they are not expected to be ever focused)\n *\n * @see {@link getTabbableNodes} to get only tabble nodes element\n *\n * @param topNodes - array of top level HTMLElements to search inside\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\n */\nexport var getFocusableNodes = function (topNodes, visibilityCache) {\n    return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);\n};\n/**\n * return list of nodes which are expected to be auto-focused\n * @param topNode\n * @param visibilityCache\n */\nexport var parentAutofocusables = function (topNode, visibilityCache) {\n    return filterFocusable(getParentAutofocusables(topNode), visibilityCache);\n};\n/*\n * Determines if element is contained in scope, including nested shadow DOMs\n */\nexport var contains = function (scope, element) {\n    if (scope.shadowRoot) {\n        return contains(scope.shadowRoot, element);\n    }\n    else {\n        if (Object.getPrototypeOf(scope).contains !== undefined &&\n            Object.getPrototypeOf(scope).contains.call(scope, element)) {\n            return true;\n        }\n        return toArray(scope.children).some(function (child) {\n            var _a;\n            if (child instanceof HTMLIFrameElement) {\n                var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;\n                if (iframeBody) {\n                    return contains(iframeBody, element);\n                }\n                return false;\n            }\n            return contains(child, element);\n        });\n    }\n};\n"]},"metadata":{},"sourceType":"module"}