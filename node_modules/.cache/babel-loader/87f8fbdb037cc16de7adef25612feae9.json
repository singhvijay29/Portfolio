{"ast":null,"code":"import { focusOn } from './commands';\nimport { getTabbableNodes, contains, getFocusableNodes } from './utils/DOMutils';\nimport { asArray } from './utils/array';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\n\nexport var getRelativeFocusable = function (element, scope, useTabbables) {\n  if (!element || !scope) {\n    console.error('no element or scope given');\n    return {};\n  }\n\n  var shards = asArray(scope);\n\n  if (shards.every(function (shard) {\n    return !contains(shard, element);\n  })) {\n    console.error('Active element is not contained in the scope');\n    return {};\n  }\n\n  var focusables = useTabbables ? getTabbableNodes(shards, new Map()) : getFocusableNodes(shards, new Map());\n  var current = focusables.findIndex(function (_a) {\n    var node = _a.node;\n    return node === element;\n  });\n\n  if (current === -1) {\n    // an edge case, when anchor element is not found\n    return undefined;\n  }\n\n  return {\n    prev: focusables[current - 1],\n    next: focusables[current + 1],\n    first: focusables[0],\n    last: focusables[focusables.length - 1]\n  };\n};\n\nvar getBoundary = function (shards, useTabbables) {\n  var set = useTabbables ? getTabbableNodes(asArray(shards), new Map()) : getFocusableNodes(asArray(shards), new Map());\n  return {\n    first: set[0],\n    last: set[set.length - 1]\n  };\n};\n\nvar defaultOptions = function (options) {\n  return Object.assign({\n    scope: document.body,\n    cycle: true,\n    onlyTabbable: true\n  }, options);\n};\n\nvar moveFocus = function (fromElement, options, cb) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var newOptions = defaultOptions(options);\n  var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);\n\n  if (!solution) {\n    return;\n  }\n\n  var target = cb(solution, newOptions.cycle);\n\n  if (target) {\n    focusOn(target.node, newOptions.focusOptions);\n  }\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\n\n\nexport var focusNextElement = function (fromElement, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  moveFocus(fromElement, options, function (_a, cycle) {\n    var next = _a.next,\n        first = _a.first;\n    return next || cycle && first;\n  });\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\n\nexport var focusPrevElement = function (fromElement, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  moveFocus(fromElement, options, function (_a, cycle) {\n    var prev = _a.prev,\n        last = _a.last;\n    return prev || cycle && last;\n  });\n};\n\nvar pickBoundary = function (scope, options, what) {\n  var _a;\n\n  var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);\n  var node = boundary[what];\n\n  if (node) {\n    focusOn(node.node, options.focusOptions);\n  }\n};\n/**\n * focuses first element in the tab-order\n * @param {FocusNextOptions} options - focus options\n */\n\n\nexport var focusFirstElement = function (scope, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  pickBoundary(scope, options, 'first');\n};\n/**\n * focuses last element in the tab order\n * @param {FocusNextOptions} options - focus options\n */\n\nexport var focusLastElement = function (scope, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  pickBoundary(scope, options, 'last');\n};","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/focus-lock/dist/es2015/sibling.js"],"names":["focusOn","getTabbableNodes","contains","getFocusableNodes","asArray","getRelativeFocusable","element","scope","useTabbables","console","error","shards","every","shard","focusables","Map","current","findIndex","_a","node","undefined","prev","next","first","last","length","getBoundary","set","defaultOptions","options","Object","assign","document","body","cycle","onlyTabbable","moveFocus","fromElement","cb","newOptions","solution","target","focusOptions","focusNextElement","focusPrevElement","pickBoundary","what","boundary","focusFirstElement","focusLastElement"],"mappings":"AAAA,SAASA,OAAT,QAAwB,YAAxB;AACA,SAASC,gBAAT,EAA2BC,QAA3B,EAAqCC,iBAArC,QAA8D,kBAA9D;AACA,SAASC,OAAT,QAAwB,eAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,oBAAoB,GAAG,UAAUC,OAAV,EAAmBC,KAAnB,EAA0BC,YAA1B,EAAwC;AACtE,MAAI,CAACF,OAAD,IAAY,CAACC,KAAjB,EAAwB;AACpBE,IAAAA,OAAO,CAACC,KAAR,CAAc,2BAAd;AACA,WAAO,EAAP;AACH;;AACD,MAAIC,MAAM,GAAGP,OAAO,CAACG,KAAD,CAApB;;AACA,MAAII,MAAM,CAACC,KAAP,CAAa,UAAUC,KAAV,EAAiB;AAAE,WAAO,CAACX,QAAQ,CAACW,KAAD,EAAQP,OAAR,CAAhB;AAAmC,GAAnE,CAAJ,EAA0E;AACtEG,IAAAA,OAAO,CAACC,KAAR,CAAc,8CAAd;AACA,WAAO,EAAP;AACH;;AACD,MAAII,UAAU,GAAGN,YAAY,GACvBP,gBAAgB,CAACU,MAAD,EAAS,IAAII,GAAJ,EAAT,CADO,GAEvBZ,iBAAiB,CAACQ,MAAD,EAAS,IAAII,GAAJ,EAAT,CAFvB;AAGA,MAAIC,OAAO,GAAGF,UAAU,CAACG,SAAX,CAAqB,UAAUC,EAAV,EAAc;AAC7C,QAAIC,IAAI,GAAGD,EAAE,CAACC,IAAd;AACA,WAAOA,IAAI,KAAKb,OAAhB;AACH,GAHa,CAAd;;AAIA,MAAIU,OAAO,KAAK,CAAC,CAAjB,EAAoB;AAChB;AACA,WAAOI,SAAP;AACH;;AACD,SAAO;AACHC,IAAAA,IAAI,EAAEP,UAAU,CAACE,OAAO,GAAG,CAAX,CADb;AAEHM,IAAAA,IAAI,EAAER,UAAU,CAACE,OAAO,GAAG,CAAX,CAFb;AAGHO,IAAAA,KAAK,EAAET,UAAU,CAAC,CAAD,CAHd;AAIHU,IAAAA,IAAI,EAAEV,UAAU,CAACA,UAAU,CAACW,MAAX,GAAoB,CAArB;AAJb,GAAP;AAMH,CA3BM;;AA4BP,IAAIC,WAAW,GAAG,UAAUf,MAAV,EAAkBH,YAAlB,EAAgC;AAC9C,MAAImB,GAAG,GAAGnB,YAAY,GAChBP,gBAAgB,CAACG,OAAO,CAACO,MAAD,CAAR,EAAkB,IAAII,GAAJ,EAAlB,CADA,GAEhBZ,iBAAiB,CAACC,OAAO,CAACO,MAAD,CAAR,EAAkB,IAAII,GAAJ,EAAlB,CAFvB;AAGA,SAAO;AACHQ,IAAAA,KAAK,EAAEI,GAAG,CAAC,CAAD,CADP;AAEHH,IAAAA,IAAI,EAAEG,GAAG,CAACA,GAAG,CAACF,MAAJ,GAAa,CAAd;AAFN,GAAP;AAIH,CARD;;AASA,IAAIG,cAAc,GAAG,UAAUC,OAAV,EAAmB;AACpC,SAAOC,MAAM,CAACC,MAAP,CAAc;AACjBxB,IAAAA,KAAK,EAAEyB,QAAQ,CAACC,IADC;AAEjBC,IAAAA,KAAK,EAAE,IAFU;AAGjBC,IAAAA,YAAY,EAAE;AAHG,GAAd,EAIJN,OAJI,CAAP;AAKH,CAND;;AAOA,IAAIO,SAAS,GAAG,UAAUC,WAAV,EAAuBR,OAAvB,EAAgCS,EAAhC,EAAoC;AAChD,MAAIT,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AACzC,MAAIU,UAAU,GAAGX,cAAc,CAACC,OAAD,CAA/B;AACA,MAAIW,QAAQ,GAAGnC,oBAAoB,CAACgC,WAAD,EAAcE,UAAU,CAAChC,KAAzB,EAAgCgC,UAAU,CAACJ,YAA3C,CAAnC;;AACA,MAAI,CAACK,QAAL,EAAe;AACX;AACH;;AACD,MAAIC,MAAM,GAAGH,EAAE,CAACE,QAAD,EAAWD,UAAU,CAACL,KAAtB,CAAf;;AACA,MAAIO,MAAJ,EAAY;AACRzC,IAAAA,OAAO,CAACyC,MAAM,CAACtB,IAAR,EAAcoB,UAAU,CAACG,YAAzB,CAAP;AACH;AACJ,CAXD;AAYA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAIC,gBAAgB,GAAG,UAAUN,WAAV,EAAuBR,OAAvB,EAAgC;AAC1D,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AACzCO,EAAAA,SAAS,CAACC,WAAD,EAAcR,OAAd,EAAuB,UAAUX,EAAV,EAAcgB,KAAd,EAAqB;AACjD,QAAIZ,IAAI,GAAGJ,EAAE,CAACI,IAAd;AAAA,QAAoBC,KAAK,GAAGL,EAAE,CAACK,KAA/B;AACA,WAAOD,IAAI,IAAKY,KAAK,IAAIX,KAAzB;AACH,GAHQ,CAAT;AAIH,CANM;AAOP;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIqB,gBAAgB,GAAG,UAAUP,WAAV,EAAuBR,OAAvB,EAAgC;AAC1D,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AACzCO,EAAAA,SAAS,CAACC,WAAD,EAAcR,OAAd,EAAuB,UAAUX,EAAV,EAAcgB,KAAd,EAAqB;AACjD,QAAIb,IAAI,GAAGH,EAAE,CAACG,IAAd;AAAA,QAAoBG,IAAI,GAAGN,EAAE,CAACM,IAA9B;AACA,WAAOH,IAAI,IAAKa,KAAK,IAAIV,IAAzB;AACH,GAHQ,CAAT;AAIH,CANM;;AAOP,IAAIqB,YAAY,GAAG,UAAUtC,KAAV,EAAiBsB,OAAjB,EAA0BiB,IAA1B,EAAgC;AAC/C,MAAI5B,EAAJ;;AACA,MAAI6B,QAAQ,GAAGrB,WAAW,CAACnB,KAAD,EAAQ,CAACW,EAAE,GAAGW,OAAO,CAACM,YAAd,MAAgC,IAAhC,IAAwCjB,EAAE,KAAK,KAAK,CAApD,GAAwDA,EAAxD,GAA6D,IAArE,CAA1B;AACA,MAAIC,IAAI,GAAG4B,QAAQ,CAACD,IAAD,CAAnB;;AACA,MAAI3B,IAAJ,EAAU;AACNnB,IAAAA,OAAO,CAACmB,IAAI,CAACA,IAAN,EAAYU,OAAO,CAACa,YAApB,CAAP;AACH;AACJ,CAPD;AAQA;AACA;AACA;AACA;;;AACA,OAAO,IAAIM,iBAAiB,GAAG,UAAUzC,KAAV,EAAiBsB,OAAjB,EAA0B;AACrD,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AACzCgB,EAAAA,YAAY,CAACtC,KAAD,EAAQsB,OAAR,EAAiB,OAAjB,CAAZ;AACH,CAHM;AAIP;AACA;AACA;AACA;;AACA,OAAO,IAAIoB,gBAAgB,GAAG,UAAU1C,KAAV,EAAiBsB,OAAjB,EAA0B;AACpD,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AACzCgB,EAAAA,YAAY,CAACtC,KAAD,EAAQsB,OAAR,EAAiB,MAAjB,CAAZ;AACH,CAHM","sourcesContent":["import { focusOn } from './commands';\nimport { getTabbableNodes, contains, getFocusableNodes } from './utils/DOMutils';\nimport { asArray } from './utils/array';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\nexport var getRelativeFocusable = function (element, scope, useTabbables) {\n    if (!element || !scope) {\n        console.error('no element or scope given');\n        return {};\n    }\n    var shards = asArray(scope);\n    if (shards.every(function (shard) { return !contains(shard, element); })) {\n        console.error('Active element is not contained in the scope');\n        return {};\n    }\n    var focusables = useTabbables\n        ? getTabbableNodes(shards, new Map())\n        : getFocusableNodes(shards, new Map());\n    var current = focusables.findIndex(function (_a) {\n        var node = _a.node;\n        return node === element;\n    });\n    if (current === -1) {\n        // an edge case, when anchor element is not found\n        return undefined;\n    }\n    return {\n        prev: focusables[current - 1],\n        next: focusables[current + 1],\n        first: focusables[0],\n        last: focusables[focusables.length - 1],\n    };\n};\nvar getBoundary = function (shards, useTabbables) {\n    var set = useTabbables\n        ? getTabbableNodes(asArray(shards), new Map())\n        : getFocusableNodes(asArray(shards), new Map());\n    return {\n        first: set[0],\n        last: set[set.length - 1],\n    };\n};\nvar defaultOptions = function (options) {\n    return Object.assign({\n        scope: document.body,\n        cycle: true,\n        onlyTabbable: true,\n    }, options);\n};\nvar moveFocus = function (fromElement, options, cb) {\n    if (options === void 0) { options = {}; }\n    var newOptions = defaultOptions(options);\n    var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);\n    if (!solution) {\n        return;\n    }\n    var target = cb(solution, newOptions.cycle);\n    if (target) {\n        focusOn(target.node, newOptions.focusOptions);\n    }\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusNextElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    moveFocus(fromElement, options, function (_a, cycle) {\n        var next = _a.next, first = _a.first;\n        return next || (cycle && first);\n    });\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusPrevElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    moveFocus(fromElement, options, function (_a, cycle) {\n        var prev = _a.prev, last = _a.last;\n        return prev || (cycle && last);\n    });\n};\nvar pickBoundary = function (scope, options, what) {\n    var _a;\n    var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);\n    var node = boundary[what];\n    if (node) {\n        focusOn(node.node, options.focusOptions);\n    }\n};\n/**\n * focuses first element in the tab-order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusFirstElement = function (scope, options) {\n    if (options === void 0) { options = {}; }\n    pickBoundary(scope, options, 'first');\n};\n/**\n * focuses last element in the tab order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusLastElement = function (scope, options) {\n    if (options === void 0) { options = {}; }\n    pickBoundary(scope, options, 'last');\n};\n"]},"metadata":{},"sourceType":"module"}