{"ast":null,"code":"import { millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\n\nfunction getSpringOptions(options) {\n  let springOptions = {\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false,\n    ...options\n  }; // stiffness/damping/mass overrides duration/bounce\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = { ...springOptions,\n      ...derived,\n      mass: 1.0\n    };\n    springOptions.isResolvedFromDuration = true;\n  }\n\n  return springOptions;\n}\n\nfunction spring(_ref) {\n  let {\n    keyframes,\n    restDelta,\n    restSpeed,\n    ...options\n  } = _ref;\n  const origin = keyframes[0];\n  const target = keyframes[keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n\n  const state = {\n    done: false,\n    value: origin\n  };\n  const {\n    stiffness,\n    damping,\n    mass,\n    duration,\n    velocity,\n    isResolvedFromDuration\n  } = getSpringOptions({ ...options,\n    velocity: -millisecondsToSeconds(options.velocity || 0)\n  });\n  const initialVelocity = velocity || 0.0;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  const initialDelta = target - origin;\n  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n  /**\n   * If we're working on a granular scale, use smaller defaults for determining\n   * when the spring is finished.\n   *\n   * These defaults have been selected emprically based on what strikes a good\n   * ratio between feeling good and finishing as soon as changes are imperceptible.\n   */\n\n  const isGranularScale = Math.abs(initialDelta) < 5;\n  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n  restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n  let resolveSpring;\n\n  if (dampingRatio < 1) {\n    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio); // Underdamped spring\n\n    resolveSpring = t => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else if (dampingRatio === 1) {\n    // Critically damped spring\n    resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n  } else {\n    // Overdamped spring\n    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n    resolveSpring = t => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t); // When performing sinh or cosh values can hit Infinity so we cap them here\n\n      const freqForT = Math.min(dampedAngularFreq * t, 300);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n    };\n  }\n\n  return {\n    calculatedDuration: isResolvedFromDuration ? duration || null : null,\n    next: t => {\n      const current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        let currentVelocity = initialVelocity;\n\n        if (t !== 0) {\n          /**\n           * We only need to calculate velocity for under-damped springs\n           * as over- and critically-damped springs can't overshoot, so\n           * checking only for displacement is enough.\n           */\n          if (dampingRatio < 1) {\n            currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? target : current;\n      return state;\n    }\n  };\n}\n\nexport { spring };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs"],"names":["millisecondsToSeconds","calcGeneratorVelocity","findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","velocity","stiffness","damping","mass","isResolvedFromDuration","derived","spring","keyframes","restDelta","restSpeed","origin","target","length","state","done","value","duration","initialVelocity","dampingRatio","Math","sqrt","initialDelta","undampedAngularFreq","isGranularScale","abs","resolveSpring","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","calculatedDuration","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold"],"mappings":"AAAA,SAASA,qBAAT,QAAsC,oCAAtC;AACA,SAASC,qBAAT,QAAsC,uBAAtC;AACA,SAASC,UAAT,EAAqBC,eAArB,QAA4C,YAA5C;AAEA,MAAMC,YAAY,GAAG,CAAC,UAAD,EAAa,QAAb,CAArB;AACA,MAAMC,WAAW,GAAG,CAAC,WAAD,EAAc,SAAd,EAAyB,MAAzB,CAApB;;AACA,SAASC,YAAT,CAAsBC,OAAtB,EAA+BC,IAA/B,EAAqC;AACjC,SAAOA,IAAI,CAACC,IAAL,CAAWC,GAAD,IAASH,OAAO,CAACG,GAAD,CAAP,KAAiBC,SAApC,CAAP;AACH;;AACD,SAASC,gBAAT,CAA0BL,OAA1B,EAAmC;AAC/B,MAAIM,aAAa,GAAG;AAChBC,IAAAA,QAAQ,EAAE,GADM;AAEhBC,IAAAA,SAAS,EAAE,GAFK;AAGhBC,IAAAA,OAAO,EAAE,EAHO;AAIhBC,IAAAA,IAAI,EAAE,GAJU;AAKhBC,IAAAA,sBAAsB,EAAE,KALR;AAMhB,OAAGX;AANa,GAApB,CAD+B,CAS/B;;AACA,MAAI,CAACD,YAAY,CAACC,OAAD,EAAUF,WAAV,CAAb,IACAC,YAAY,CAACC,OAAD,EAAUH,YAAV,CADhB,EACyC;AACrC,UAAMe,OAAO,GAAGjB,UAAU,CAACK,OAAD,CAA1B;AACAM,IAAAA,aAAa,GAAG,EACZ,GAAGA,aADS;AAEZ,SAAGM,OAFS;AAGZF,MAAAA,IAAI,EAAE;AAHM,KAAhB;AAKAJ,IAAAA,aAAa,CAACK,sBAAd,GAAuC,IAAvC;AACH;;AACD,SAAOL,aAAP;AACH;;AACD,SAASO,MAAT,OAAiE;AAAA,MAAjD;AAAEC,IAAAA,SAAF;AAAaC,IAAAA,SAAb;AAAwBC,IAAAA,SAAxB;AAAmC,OAAGhB;AAAtC,GAAiD;AAC7D,QAAMiB,MAAM,GAAGH,SAAS,CAAC,CAAD,CAAxB;AACA,QAAMI,MAAM,GAAGJ,SAAS,CAACA,SAAS,CAACK,MAAV,GAAmB,CAApB,CAAxB;AACA;AACJ;AACA;AACA;;AACI,QAAMC,KAAK,GAAG;AAAEC,IAAAA,IAAI,EAAE,KAAR;AAAeC,IAAAA,KAAK,EAAEL;AAAtB,GAAd;AACA,QAAM;AAAET,IAAAA,SAAF;AAAaC,IAAAA,OAAb;AAAsBC,IAAAA,IAAtB;AAA4Ba,IAAAA,QAA5B;AAAsChB,IAAAA,QAAtC;AAAgDI,IAAAA;AAAhD,MAA4EN,gBAAgB,CAAC,EAC/F,GAAGL,OAD4F;AAE/FO,IAAAA,QAAQ,EAAE,CAACd,qBAAqB,CAACO,OAAO,CAACO,QAAR,IAAoB,CAArB;AAF+D,GAAD,CAAlG;AAIA,QAAMiB,eAAe,GAAGjB,QAAQ,IAAI,GAApC;AACA,QAAMkB,YAAY,GAAGhB,OAAO,IAAI,IAAIiB,IAAI,CAACC,IAAL,CAAUnB,SAAS,GAAGE,IAAtB,CAAR,CAA5B;AACA,QAAMkB,YAAY,GAAGV,MAAM,GAAGD,MAA9B;AACA,QAAMY,mBAAmB,GAAGpC,qBAAqB,CAACiC,IAAI,CAACC,IAAL,CAAUnB,SAAS,GAAGE,IAAtB,CAAD,CAAjD;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI,QAAMoB,eAAe,GAAGJ,IAAI,CAACK,GAAL,CAASH,YAAT,IAAyB,CAAjD;AACAZ,EAAAA,SAAS,KAAKA,SAAS,GAAGc,eAAe,GAAG,IAAH,GAAU,CAA1C,CAAT;AACAf,EAAAA,SAAS,KAAKA,SAAS,GAAGe,eAAe,GAAG,KAAH,GAAW,GAA3C,CAAT;AACA,MAAIE,aAAJ;;AACA,MAAIP,YAAY,GAAG,CAAnB,EAAsB;AAClB,UAAMQ,WAAW,GAAGrC,eAAe,CAACiC,mBAAD,EAAsBJ,YAAtB,CAAnC,CADkB,CAElB;;AACAO,IAAAA,aAAa,GAAIE,CAAD,IAAO;AACnB,YAAMC,QAAQ,GAAGT,IAAI,CAACU,GAAL,CAAS,CAACX,YAAD,GAAgBI,mBAAhB,GAAsCK,CAA/C,CAAjB;AACA,aAAQhB,MAAM,GACViB,QAAQ,IACF,CAACX,eAAe,GACdC,YAAY,GAAGI,mBAAf,GAAqCD,YADvC,IAEEK,WAFH,GAGGP,IAAI,CAACW,GAAL,CAASJ,WAAW,GAAGC,CAAvB,CAHH,GAIGN,YAAY,GAAGF,IAAI,CAACY,GAAL,CAASL,WAAW,GAAGC,CAAvB,CALf,CADZ;AAOH,KATD;AAUH,GAbD,MAcK,IAAIT,YAAY,KAAK,CAArB,EAAwB;AACzB;AACAO,IAAAA,aAAa,GAAIE,CAAD,IAAOhB,MAAM,GACzBQ,IAAI,CAACU,GAAL,CAAS,CAACP,mBAAD,GAAuBK,CAAhC,KACKN,YAAY,GACT,CAACJ,eAAe,GAAGK,mBAAmB,GAAGD,YAAzC,IAAyDM,CAFjE,CADJ;AAIH,GANI,MAOA;AACD;AACA,UAAMK,iBAAiB,GAAGV,mBAAmB,GAAGH,IAAI,CAACC,IAAL,CAAUF,YAAY,GAAGA,YAAf,GAA8B,CAAxC,CAAhD;;AACAO,IAAAA,aAAa,GAAIE,CAAD,IAAO;AACnB,YAAMC,QAAQ,GAAGT,IAAI,CAACU,GAAL,CAAS,CAACX,YAAD,GAAgBI,mBAAhB,GAAsCK,CAA/C,CAAjB,CADmB,CAEnB;;AACA,YAAMM,QAAQ,GAAGd,IAAI,CAACe,GAAL,CAASF,iBAAiB,GAAGL,CAA7B,EAAgC,GAAhC,CAAjB;AACA,aAAQhB,MAAM,GACTiB,QAAQ,IACJ,CAACX,eAAe,GACbC,YAAY,GAAGI,mBAAf,GAAqCD,YADxC,IAEGF,IAAI,CAACgB,IAAL,CAAUF,QAAV,CAFH,GAGGD,iBAAiB,GACbX,YADJ,GAEIF,IAAI,CAACiB,IAAL,CAAUH,QAAV,CANH,CAAT,GAOID,iBARR;AASH,KAbD;AAcH;;AACD,SAAO;AACHK,IAAAA,kBAAkB,EAAEjC,sBAAsB,GAAGY,QAAQ,IAAI,IAAf,GAAsB,IAD7D;AAEHsB,IAAAA,IAAI,EAAGX,CAAD,IAAO;AACT,YAAMY,OAAO,GAAGd,aAAa,CAACE,CAAD,CAA7B;;AACA,UAAI,CAACvB,sBAAL,EAA6B;AACzB,YAAIoC,eAAe,GAAGvB,eAAtB;;AACA,YAAIU,CAAC,KAAK,CAAV,EAAa;AACT;AACpB;AACA;AACA;AACA;AACoB,cAAIT,YAAY,GAAG,CAAnB,EAAsB;AAClBsB,YAAAA,eAAe,GAAGrD,qBAAqB,CAACsC,aAAD,EAAgBE,CAAhB,EAAmBY,OAAnB,CAAvC;AACH,WAFD,MAGK;AACDC,YAAAA,eAAe,GAAG,CAAlB;AACH;AACJ;;AACD,cAAMC,wBAAwB,GAAGtB,IAAI,CAACK,GAAL,CAASgB,eAAT,KAA6B/B,SAA9D;AACA,cAAMiC,4BAA4B,GAAGvB,IAAI,CAACK,GAAL,CAASb,MAAM,GAAG4B,OAAlB,KAA8B/B,SAAnE;AACAK,QAAAA,KAAK,CAACC,IAAN,GACI2B,wBAAwB,IAAIC,4BADhC;AAEH,OAnBD,MAoBK;AACD7B,QAAAA,KAAK,CAACC,IAAN,GAAaa,CAAC,IAAIX,QAAlB;AACH;;AACDH,MAAAA,KAAK,CAACE,KAAN,GAAcF,KAAK,CAACC,IAAN,GAAaH,MAAb,GAAsB4B,OAApC;AACA,aAAO1B,KAAP;AACH;AA7BE,GAAP;AA+BH;;AAED,SAASP,MAAT","sourcesContent":["import { millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\n    const origin = keyframes[0];\n    const target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    return {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n    };\n}\n\nexport { spring };\n"]},"metadata":{},"sourceType":"module"}