{"ast":null,"code":"var alwaysContainsScroll = function (node) {\n  // textarea will always _contain_ scroll inside self. It only can be hidden\n  return node.tagName === 'TEXTAREA';\n};\n\nvar elementCanBeScrolled = function (node, overflow) {\n  if (!(node instanceof Element)) {\n    return false;\n  }\n\n  var styles = window.getComputedStyle(node);\n  return (// not-not-scrollable\n    styles[overflow] !== 'hidden' && // contains scroll inside self\n    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible')\n  );\n};\n\nvar elementCouldBeVScrolled = function (node) {\n  return elementCanBeScrolled(node, 'overflowY');\n};\n\nvar elementCouldBeHScrolled = function (node) {\n  return elementCanBeScrolled(node, 'overflowX');\n};\n\nexport var locationCouldBeScrolled = function (axis, node) {\n  var ownerDocument = node.ownerDocument;\n  var current = node;\n\n  do {\n    // Skip over shadow root\n    if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n      current = current.host;\n    }\n\n    var isScrollable = elementCouldBeScrolled(axis, current);\n\n    if (isScrollable) {\n      var _a = getScrollVariables(axis, current),\n          scrollHeight = _a[1],\n          clientHeight = _a[2];\n\n      if (scrollHeight > clientHeight) {\n        return true;\n      }\n    }\n\n    current = current.parentNode;\n  } while (current && current !== ownerDocument.body);\n\n  return false;\n};\n\nvar getVScrollVariables = function (_a) {\n  var scrollTop = _a.scrollTop,\n      scrollHeight = _a.scrollHeight,\n      clientHeight = _a.clientHeight;\n  return [scrollTop, scrollHeight, clientHeight];\n};\n\nvar getHScrollVariables = function (_a) {\n  var scrollLeft = _a.scrollLeft,\n      scrollWidth = _a.scrollWidth,\n      clientWidth = _a.clientWidth;\n  return [scrollLeft, scrollWidth, clientWidth];\n};\n\nvar elementCouldBeScrolled = function (axis, node) {\n  return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\n\nvar getScrollVariables = function (axis, node) {\n  return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\n\nvar getDirectionFactor = function (axis, direction) {\n  /**\n   * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n   * and then increasingly negative as you scroll towards the end of the content.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n   */\n  return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\n\nexport var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\n  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n  var delta = directionFactor * sourceDelta; // find scrollable target\n\n  var target = event.target;\n  var targetInLock = endTarget.contains(target);\n  var shouldCancelScroll = false;\n  var isDeltaPositive = delta > 0;\n  var availableScroll = 0;\n  var availableScrollTop = 0;\n\n  do {\n    var _a = getScrollVariables(axis, target),\n        position = _a[0],\n        scroll_1 = _a[1],\n        capacity = _a[2];\n\n    var elementScroll = scroll_1 - capacity - directionFactor * position;\n\n    if (position || elementScroll) {\n      if (elementCouldBeScrolled(axis, target)) {\n        availableScroll += elementScroll;\n        availableScrollTop += position;\n      }\n    }\n\n    if (target instanceof ShadowRoot) {\n      target = target.host;\n    } else {\n      target = target.parentNode;\n    }\n  } while ( // portaled content\n  !targetInLock && target !== document.body || // self content\n  targetInLock && (endTarget.contains(target) || endTarget === target)); // handle epsilon around 0 (non standard zoom levels)\n\n\n  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {\n    shouldCancelScroll = true;\n  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {\n    shouldCancelScroll = true;\n  }\n\n  return shouldCancelScroll;\n};","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/react-remove-scroll/dist/es2015/handleScroll.js"],"names":["alwaysContainsScroll","node","tagName","elementCanBeScrolled","overflow","Element","styles","window","getComputedStyle","overflowY","overflowX","elementCouldBeVScrolled","elementCouldBeHScrolled","locationCouldBeScrolled","axis","ownerDocument","current","ShadowRoot","host","isScrollable","elementCouldBeScrolled","_a","getScrollVariables","scrollHeight","clientHeight","parentNode","body","getVScrollVariables","scrollTop","getHScrollVariables","scrollLeft","scrollWidth","clientWidth","getDirectionFactor","direction","handleScroll","endTarget","event","sourceDelta","noOverscroll","directionFactor","delta","target","targetInLock","contains","shouldCancelScroll","isDeltaPositive","availableScroll","availableScrollTop","position","scroll_1","capacity","elementScroll","document","Math","abs"],"mappings":"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","sourcesContent":["var alwaysContainsScroll = function (node) {\n    // textarea will always _contain_ scroll inside self. It only can be hidden\n    return node.tagName === 'TEXTAREA';\n};\nvar elementCanBeScrolled = function (node, overflow) {\n    if (!(node instanceof Element)) {\n        return false;\n    }\n    var styles = window.getComputedStyle(node);\n    return (\n    // not-not-scrollable\n    styles[overflow] !== 'hidden' &&\n        // contains scroll inside self\n        !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === 'visible'));\n};\nvar elementCouldBeVScrolled = function (node) { return elementCanBeScrolled(node, 'overflowY'); };\nvar elementCouldBeHScrolled = function (node) { return elementCanBeScrolled(node, 'overflowX'); };\nexport var locationCouldBeScrolled = function (axis, node) {\n    var ownerDocument = node.ownerDocument;\n    var current = node;\n    do {\n        // Skip over shadow root\n        if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {\n            current = current.host;\n        }\n        var isScrollable = elementCouldBeScrolled(axis, current);\n        if (isScrollable) {\n            var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];\n            if (scrollHeight > clientHeight) {\n                return true;\n            }\n        }\n        current = current.parentNode;\n    } while (current && current !== ownerDocument.body);\n    return false;\n};\nvar getVScrollVariables = function (_a) {\n    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n    return [\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n    ];\n};\nvar getHScrollVariables = function (_a) {\n    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;\n    return [\n        scrollLeft,\n        scrollWidth,\n        clientWidth,\n    ];\n};\nvar elementCouldBeScrolled = function (axis, node) {\n    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);\n};\nvar getScrollVariables = function (axis, node) {\n    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);\n};\nvar getDirectionFactor = function (axis, direction) {\n    /**\n     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,\n     * and then increasingly negative as you scroll towards the end of the content.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n     */\n    return axis === 'h' && direction === 'rtl' ? -1 : 1;\n};\nexport var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {\n    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);\n    var delta = directionFactor * sourceDelta;\n    // find scrollable target\n    var target = event.target;\n    var targetInLock = endTarget.contains(target);\n    var shouldCancelScroll = false;\n    var isDeltaPositive = delta > 0;\n    var availableScroll = 0;\n    var availableScrollTop = 0;\n    do {\n        var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];\n        var elementScroll = scroll_1 - capacity - directionFactor * position;\n        if (position || elementScroll) {\n            if (elementCouldBeScrolled(axis, target)) {\n                availableScroll += elementScroll;\n                availableScrollTop += position;\n            }\n        }\n        if (target instanceof ShadowRoot) {\n            target = target.host;\n        }\n        else {\n            target = target.parentNode;\n        }\n    } while (\n    // portaled content\n    (!targetInLock && target !== document.body) ||\n        // self content\n        (targetInLock && (endTarget.contains(target) || endTarget === target)));\n    // handle epsilon around 0 (non standard zoom levels)\n    if (isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScroll) < 1) || (!noOverscroll && delta > availableScroll))) {\n        shouldCancelScroll = true;\n    }\n    else if (!isDeltaPositive &&\n        ((noOverscroll && Math.abs(availableScrollTop) < 1) || (!noOverscroll && -delta > availableScrollTop))) {\n        shouldCancelScroll = true;\n    }\n    return shouldCancelScroll;\n};\n"]},"metadata":{},"sourceType":"module"}