{"ast":null,"code":"import { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nconst defaultSegmentEasing = \"easeInOut\";\n\nfunction createAnimationsFromSequence(sequence) {\n  let {\n    defaultTransition = {},\n    ...sequenceTransition\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let scope = arguments.length > 2 ? arguments[2] : undefined;\n  const defaultDuration = defaultTransition.duration || 0.3;\n  const animationDefinitions = new Map();\n  const sequences = new Map();\n  const elementCache = {};\n  const timeLabels = new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the sequence array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n\n  for (let i = 0; i < sequence.length; i++) {\n    const segment = sequence[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n\n    let [subject, keyframes, transition = {}] = segment;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n\n\n    let maxDuration = 0;\n\n    const resolveValueSequence = function (valueKeyframes, valueTransition, valueSequence) {\n      let elementIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      let numElements = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n      const {\n        delay = 0,\n        times = defaultOffset(valueKeyframesAsList),\n        type = \"keyframes\",\n        ...remainingTransition\n      } = valueTransition;\n      let {\n        ease = defaultTransition.ease || \"easeOut\",\n        duration\n      } = valueTransition;\n      /**\n       * Resolve stagger() if defined.\n       */\n\n      const calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numElements) : delay;\n      /**\n       * If this animation should and can use a spring, generate a spring easing function.\n       */\n\n      const numKeyframes = valueKeyframesAsList.length;\n\n      if (numKeyframes <= 2 && type === \"spring\") {\n        /**\n         * As we're creating an easing function from a spring,\n         * ideally we want to generate it using the real distance\n         * between the two keyframes. However this isn't always\n         * possible - in these situations we use 0-100.\n         */\n        let absoluteDelta = 100;\n\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n\n        const springTransition = { ...remainingTransition\n        };\n\n        if (duration !== undefined) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n\n        const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n        ease = springEasing.ease;\n        duration = springEasing.duration;\n      }\n\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      const startTime = currentTime + calculatedDelay;\n      const targetTime = startTime + duration;\n      /**\n       * If there's only one time offset of 0, fill in a second with length 1\n       */\n\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\n       * Fill out if offset if fewer offsets than keyframes\n       */\n\n\n      const remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\n       * If only one value has been set, ie [1], push a null to the start of\n       * the keyframe array. This will let us mark a keyframe at this point\n       * that will later be hydrated with the previous value.\n       */\n\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\n       * Add keyframes, mapping offsets to absolute time.\n       */\n\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n\n    if (isMotionValue(subject)) {\n      const subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      /**\n       * Find all the elements specified in the definition and parse value\n       * keyframes from their timeline definitions.\n       */\n      const elements = resolveElements(subject, scope, elementCache);\n      const numElements = elements.length;\n      /**\n       * For every element in this segment, process the defined values.\n       */\n\n      for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n        /**\n         * Cast necessary, but we know these are of this type\n         */\n        keyframes = keyframes;\n        transition = transition;\n        const element = elements[elementIndex];\n        const subjectSequence = getSubjectSequence(element, sequences);\n\n        for (const key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n        }\n      }\n    }\n\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n\n\n  sequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n\n      valueSequence.sort(compareByTime);\n      const keyframes = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n\n      for (let i = 0; i < valueSequence.length; i++) {\n        const {\n          at,\n          value,\n          easing\n        } = valueSequence[i];\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n\n\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n\n\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n\n      const definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = { ...defaultTransition,\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset,\n        ...sequenceTransition\n      };\n    }\n  });\n  return animationDefinitions;\n}\n\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\n\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\n\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\n\nfunction getValueTransition(transition, key) {\n  return transition[key] ? { ...transition,\n    ...transition[key]\n  } : { ...transition\n  };\n}\n\nconst isNumber = keyframe => typeof keyframe === \"number\";\n\nconst isNumberKeyframesArray = keyframes => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"names":["createGeneratorEasing","resolveElements","defaultOffset","fillOffset","progress","secondsToMilliseconds","isMotionValue","calcNextTime","addKeyframes","compareByTime","defaultSegmentEasing","createAnimationsFromSequence","sequence","defaultTransition","sequenceTransition","scope","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","length","segment","set","Array","isArray","name","at","subject","keyframes","transition","undefined","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numElements","valueKeyframesAsList","keyframesAsList","delay","times","type","remainingTransition","ease","calculatedDelay","numKeyframes","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","springEasing","startTime","targetTime","remainder","unshift","max","subjectSequence","getSubjectSequence","getValueSequence","elements","element","key","getValueTransition","forEach","valueSequences","sort","valueOffset","valueEasing","value","easing","push","has","definition","get","isNumber","keyframe","every"],"mappings":"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","sourcesContent":["import { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numElements)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            if (numKeyframes <= 2 && type === \"spring\") {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            const targetTime = startTime + duration;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            /**\n             * Find all the elements specified in the definition and parse value\n             * keyframes from their timeline definitions.\n             */\n            const elements = resolveElements(subject, scope, elementCache);\n            const numElements = elements.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const element = elements[elementIndex];\n                const subjectSequence = getSubjectSequence(element, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition[key]\n        ? {\n            ...transition,\n            ...transition[key],\n        }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n"]},"metadata":{},"sourceType":"module"}