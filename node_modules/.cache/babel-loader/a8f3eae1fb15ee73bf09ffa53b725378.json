{"ast":null,"code":"'use client'; // src/use-counter.ts\n\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\";\nimport { clampValue, countDecimalPlaces, toPrecision } from \"@chakra-ui/number-utils\";\nimport { useCallback, useState } from \"react\";\n\nfunction useCounter() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = Number.MIN_SAFE_INTEGER,\n    max = Number.MAX_SAFE_INTEGER,\n    keepWithinRange = true\n  } = props;\n  const onChangeProp = useCallbackRef(onChange);\n  const [valueState, setValue] = useState(() => {\n    var _a;\n\n    if (defaultValue == null) return \"\";\n    return (_a = cast(defaultValue, stepProp, precisionProp)) != null ? _a : \"\";\n  });\n  const isControlled = typeof valueProp !== \"undefined\";\n  const value = isControlled ? valueProp : valueState;\n  const decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  const precision = precisionProp != null ? precisionProp : decimalPlaces;\n  const update = useCallback(next => {\n    if (next === value) return;\n\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n\n    onChangeProp == null ? void 0 : onChangeProp(next.toString(), parse(next));\n  }, [onChangeProp, isControlled, value]);\n  const clamp = useCallback(value2 => {\n    let nextValue = value2;\n\n    if (keepWithinRange) {\n      nextValue = clampValue(nextValue, min, max);\n    }\n\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  const increment = useCallback(function () {\n    let step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : stepProp;\n    let next;\n\n    if (value === \"\") {\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  const decrement = useCallback(function () {\n    let step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : stepProp;\n    let next;\n\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  const reset = useCallback(() => {\n    var _a;\n\n    let next;\n\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      next = (_a = cast(defaultValue, stepProp, precisionProp)) != null ? _a : min;\n    }\n\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update, min]);\n  const castValue = useCallback(value2 => {\n    var _a;\n\n    const nextValue = (_a = cast(value2, stepProp, precision)) != null ? _a : min;\n    update(nextValue);\n  }, [precision, stepProp, update, min]);\n  const valueAsNumber = parse(value);\n  const isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  const isAtMax = valueAsNumber === max;\n  const isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue\n  };\n}\n\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\n\nfunction getDecimalPlaces(value, step) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));\n}\n\nfunction cast(value, step, precision) {\n  const parsedValue = parse(value);\n  if (Number.isNaN(parsedValue)) return void 0;\n  const decimalPlaces = getDecimalPlaces(parsedValue, step);\n  return toPrecision(parsedValue, precision != null ? precision : decimalPlaces);\n}\n\nexport { useCounter };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/counter/src/use-counter.ts"],"names":["value"],"mappings":"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","sourcesContent":["import { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport {\n  clampValue,\n  countDecimalPlaces,\n  toPrecision,\n} from \"@chakra-ui/number-utils\"\nimport { useCallback, useState } from \"react\"\n\nexport interface UseCounterProps {\n  /**\n   * The callback fired when the value changes\n   */\n  onChange?(valueAsString: string, valueAsNumber: number): void\n  /**\n   * The number of decimal points used to round the value\n   */\n  precision?: number\n  /**\n   * The initial value of the counter. Should be less than `max` and greater than `min`\n   */\n  defaultValue?: string | number\n  /**\n   * The value of the counter. Should be less than `max` and greater than `min`\n   */\n  value?: string | number\n  /**\n   * The step used to increment or decrement the value\n   * @default 1\n   */\n  step?: number\n  /**\n   * The minimum value of the counter\n   * @default Number.MIN_SAFE_INTEGER\n   */\n  min?: number\n  /**\n   * The maximum value of the counter\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  max?: number\n  /**\n   * This controls the value update behavior in general.\n   *\n   * - If `true` and you use the stepper or up/down arrow keys,\n   *  the value will not exceed the `max` or go lower than `min`\n   *\n   * - If `false`, the value will be allowed to go out of range.\n   *\n   * @default true\n   */\n  keepWithinRange?: boolean\n}\n\nexport function useCounter(props: UseCounterProps = {}) {\n  const {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = Number.MIN_SAFE_INTEGER,\n    max = Number.MAX_SAFE_INTEGER,\n    keepWithinRange = true,\n  } = props\n\n  const onChangeProp = useCallbackRef(onChange)\n\n  const [valueState, setValue] = useState<string | number>(() => {\n    if (defaultValue == null) return \"\"\n    return cast(defaultValue, stepProp, precisionProp) ?? \"\"\n  })\n\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n  const isControlled = typeof valueProp !== \"undefined\"\n  const value = isControlled ? valueProp : valueState\n\n  const decimalPlaces = getDecimalPlaces(parse(value), stepProp)\n\n  const precision = precisionProp ?? decimalPlaces\n\n  const update = useCallback(\n    (next: string | number) => {\n      if (next === value) return\n      if (!isControlled) {\n        setValue(next.toString())\n      }\n      onChangeProp?.(next.toString(), parse(next))\n    },\n    [onChangeProp, isControlled, value],\n  )\n\n  // Function to clamp the value and round it to the precision\n  const clamp = useCallback(\n    (value: number) => {\n      let nextValue = value\n\n      if (keepWithinRange) {\n        nextValue = clampValue(nextValue, min, max)\n      }\n\n      return toPrecision(nextValue, precision)\n    },\n    [precision, keepWithinRange, max, min],\n  )\n\n  const increment = useCallback(\n    (step = stepProp) => {\n      let next: string | number\n\n      /**\n       * Let's follow the native browser behavior for\n       * scenarios where the input starts empty (\"\")\n       */\n      if (value === \"\") {\n        /**\n         * If `min` is set, native input, starts at the `min`.\n         * Else, it starts at `step`\n         */\n        next = parse(step)\n      } else {\n        next = parse(value) + step\n      }\n\n      next = clamp(next as number)\n      update(next)\n    },\n    [clamp, stepProp, update, value],\n  )\n\n  const decrement = useCallback(\n    (step = stepProp) => {\n      let next: string | number\n\n      // Same thing here. We'll follow native implementation\n      if (value === \"\") {\n        next = parse(-step)\n      } else {\n        next = parse(value) - step\n      }\n\n      next = clamp(next as number)\n      update(next)\n    },\n    [clamp, stepProp, update, value],\n  )\n\n  const reset = useCallback(() => {\n    let next: string | number\n    if (defaultValue == null) {\n      next = \"\"\n    } else {\n      next = cast(defaultValue, stepProp, precisionProp) ?? min\n    }\n    update(next)\n  }, [defaultValue, precisionProp, stepProp, update, min])\n\n  const castValue = useCallback(\n    (value: string | number) => {\n      const nextValue = cast(value, stepProp, precision) ?? min\n      update(nextValue)\n    },\n    [precision, stepProp, update, min],\n  )\n\n  const valueAsNumber = parse(value)\n\n  /**\n   * Common range checks\n   */\n  const isOutOfRange = valueAsNumber > max || valueAsNumber < min\n  const isAtMax = valueAsNumber === max\n  const isAtMin = valueAsNumber === min\n\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue,\n  }\n}\n\nexport type UseCounterReturn = ReturnType<typeof useCounter>\n\nfunction parse(value: string | number) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"))\n}\n\nfunction getDecimalPlaces(value: number, step: number) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value))\n}\n\nfunction cast(value: string | number, step: number, precision?: number) {\n  const parsedValue = parse(value)\n  if (Number.isNaN(parsedValue)) return undefined\n  const decimalPlaces = getDecimalPlaces(parsedValue, step)\n  return toPrecision(parsedValue, precision ?? decimalPlaces)\n}\n"]},"metadata":{},"sourceType":"module"}