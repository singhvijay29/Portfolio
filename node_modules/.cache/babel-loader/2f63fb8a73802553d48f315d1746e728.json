{"ast":null,"code":"'use client';\n\nimport { ariaAttr, callAllHandlers, dataAttr } from \"./chunk-DX64QB22.mjs\";\nimport { getIds, getIsReversed, getStyles, orient } from \"./chunk-E23N4XEN.mjs\"; // src/use-range-slider.ts\n\nimport { usePanEvent } from \"@chakra-ui/react-use-pan-event\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { percentToValue, roundValueToStep, valueToPercent, clampValue } from \"@chakra-ui/number-utils\";\nimport { useCallback, useMemo, useRef, useState, useId } from \"react\";\nimport { useSizes } from \"@chakra-ui/react-use-size\";\n\nfunction useRangeSlider(props) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    minStepsBetweenThumbs = 0,\n    ...htmlProps\n  } = props;\n  const onChangeStart = useCallbackRef(onChangeStartProp);\n  const onChangeEnd = useCallbackRef(onChangeEndProp);\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation\n  });\n  const [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : [25, 75],\n    onChange\n  });\n\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(`[range-slider] You passed an invalid value for \\`value\\` or \\`defaultValue\\`, expected \\`Array\\` but got \\`${typeof valueState}\\``);\n  }\n\n  const [isDragging, setDragging] = useState(false);\n  const [isFocused, setFocused] = useState(false);\n  const [activeIndex, setActiveIndex] = useState(-1);\n  const isInteractive = !(isDisabled || isReadOnly);\n  const initialValue = useRef(valueState);\n  const value = valueState.map(val => clampValue(val, min, max));\n  const spacing = minStepsBetweenThumbs * step;\n  const valueBounds = getValueBounds(value, min, max, spacing);\n  const stateRef = useRef({\n    eventSource: null,\n    value: [],\n    valueBounds: []\n  });\n  stateRef.current.value = value;\n  stateRef.current.valueBounds = valueBounds;\n  const reversedValue = value.map(val => max - val + min);\n  const thumbValues = isReversed ? reversedValue : value;\n  const thumbPercents = thumbValues.map(val => valueToPercent(val, min, max));\n  const isVertical = orientation === \"vertical\";\n  const trackRef = useRef(null);\n  const rootRef = useRef(null);\n  const thumbRects = useSizes({\n    getNodes() {\n      const rootNode = rootRef.current;\n      const thumbNodes = rootNode == null ? void 0 : rootNode.querySelectorAll(\"[role=slider]\");\n      return thumbNodes ? Array.from(thumbNodes) : [];\n    }\n\n  });\n  const reactId = useId();\n  const uuid = idProp != null ? idProp : reactId;\n  const ids = getIds(uuid);\n  const getValueFromPointer = useCallback(event => {\n    var _a, _b;\n\n    if (!trackRef.current) return;\n    stateRef.current.eventSource = \"pointer\";\n    const rect = trackRef.current.getBoundingClientRect();\n    const {\n      clientX,\n      clientY\n    } = (_b = (_a = event.touches) == null ? void 0 : _a[0]) != null ? _b : event;\n    const diff = isVertical ? rect.bottom - clientY : clientX - rect.left;\n    const length = isVertical ? rect.height : rect.width;\n    let percent = diff / length;\n    if (isReversed) percent = 1 - percent;\n    return percentToValue(percent, min, max);\n  }, [isVertical, isReversed, max, min]);\n  const tenSteps = (max - min) / 10;\n  const oneStep = step || (max - min) / 100;\n  const actions = useMemo(() => ({\n    setValueAtIndex(index, val) {\n      if (!isInteractive) return;\n      const bounds = stateRef.current.valueBounds[index];\n      val = parseFloat(roundValueToStep(val, bounds.min, oneStep));\n      val = clampValue(val, bounds.min, bounds.max);\n      const next = [...stateRef.current.value];\n      next[index] = val;\n      setValue(next);\n    },\n\n    setActiveIndex,\n\n    stepUp(index) {\n      let step2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : oneStep;\n      const valueAtIndex = stateRef.current.value[index];\n      const next = isReversed ? valueAtIndex - step2 : valueAtIndex + step2;\n      actions.setValueAtIndex(index, next);\n    },\n\n    stepDown(index) {\n      let step2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : oneStep;\n      const valueAtIndex = stateRef.current.value[index];\n      const next = isReversed ? valueAtIndex + step2 : valueAtIndex - step2;\n      actions.setValueAtIndex(index, next);\n    },\n\n    reset() {\n      setValue(initialValue.current);\n    }\n\n  }), [oneStep, isReversed, setValue, isInteractive]);\n  const onKeyDown = useCallback(event => {\n    const eventKey = event.key;\n    const keyMap = {\n      ArrowRight: () => actions.stepUp(activeIndex),\n      ArrowUp: () => actions.stepUp(activeIndex),\n      ArrowLeft: () => actions.stepDown(activeIndex),\n      ArrowDown: () => actions.stepDown(activeIndex),\n      PageUp: () => actions.stepUp(activeIndex, tenSteps),\n      PageDown: () => actions.stepDown(activeIndex, tenSteps),\n      Home: () => {\n        const {\n          min: value2\n        } = valueBounds[activeIndex];\n        actions.setValueAtIndex(activeIndex, value2);\n      },\n      End: () => {\n        const {\n          max: value2\n        } = valueBounds[activeIndex];\n        actions.setValueAtIndex(activeIndex, value2);\n      }\n    };\n    const action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      stateRef.current.eventSource = \"keyboard\";\n    }\n  }, [actions, activeIndex, tenSteps, valueBounds]);\n  const {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle\n  } = useMemo(() => getStyles({\n    isReversed,\n    orientation,\n    thumbRects,\n    thumbPercents\n  }), [isReversed, orientation, thumbPercents, thumbRects]);\n  const focusThumb = useCallback(index => {\n    var _a;\n\n    const idx = index != null ? index : activeIndex;\n\n    if (idx !== -1 && focusThumbOnChange) {\n      const id = ids.getThumb(idx);\n      const thumb = (_a = rootRef.current) == null ? void 0 : _a.ownerDocument.getElementById(id);\n\n      if (thumb) {\n        setTimeout(() => thumb.focus());\n      }\n    }\n  }, [focusThumbOnChange, activeIndex, ids]);\n  useUpdateEffect(() => {\n    if (stateRef.current.eventSource === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(stateRef.current.value);\n    }\n  }, [value, onChangeEnd]);\n\n  const onPanSessionStart = event => {\n    const pointValue = getValueFromPointer(event) || 0;\n    const distances = stateRef.current.value.map(val => Math.abs(val - pointValue));\n    const closest = Math.min(...distances);\n    let index = distances.indexOf(closest);\n    const thumbsAtPosition = distances.filter(distance => distance === closest);\n    const isThumbStacked = thumbsAtPosition.length > 1;\n\n    if (isThumbStacked && pointValue > stateRef.current.value[index]) {\n      index = index + thumbsAtPosition.length - 1;\n    }\n\n    setActiveIndex(index);\n    actions.setValueAtIndex(index, pointValue);\n    focusThumb(index);\n  };\n\n  const onPan = event => {\n    if (activeIndex == -1) return;\n    const pointValue = getValueFromPointer(event) || 0;\n    setActiveIndex(activeIndex);\n    actions.setValueAtIndex(activeIndex, pointValue);\n    focusThumb(activeIndex);\n  };\n\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return;\n      setDragging(true);\n      onPanSessionStart(event);\n      onChangeStart == null ? void 0 : onChangeStart(stateRef.current.value);\n    },\n\n    onPanSessionEnd() {\n      if (!isInteractive) return;\n      setDragging(false);\n      onChangeEnd == null ? void 0 : onChangeEnd(stateRef.current.value);\n    },\n\n    onPan(event) {\n      if (!isInteractive) return;\n      onPan(event);\n    }\n\n  });\n  const getRootProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ...htmlProps,\n      id: ids.root,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: { ...props2.style,\n        ...rootStyle\n      }\n    };\n  }, [htmlProps, isDisabled, isFocused, rootStyle, ids]);\n  const getTrackProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ref: mergeRefs(ref, trackRef),\n      id: ids.track,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: { ...props2.style,\n        ...trackStyle\n      }\n    };\n  }, [isDisabled, trackStyle, ids]);\n  const getInnerTrackProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ref,\n      id: ids.innerTrack,\n      style: { ...props2.style,\n        ...innerTrackStyle\n      }\n    };\n  }, [innerTrackStyle, ids]);\n  const getThumbProps = useCallback(function (props2) {\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    var _a;\n\n    const {\n      index,\n      ...rest\n    } = props2;\n    const valueAtIndex = value[index];\n\n    if (valueAtIndex == null) {\n      throw new TypeError(`[range-slider > thumb] Cannot find value at index \\`${index}\\`. The \\`value\\` or \\`defaultValue\\` length is : ${value.length}`);\n    }\n\n    const bounds = valueBounds[index];\n    return { ...rest,\n      ref,\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : void 0,\n      id: ids.getThumb(index),\n      \"data-active\": dataAttr(isDragging && activeIndex === index),\n      \"aria-valuetext\": (_a = getAriaValueText == null ? void 0 : getAriaValueText(valueAtIndex)) != null ? _a : ariaValueText == null ? void 0 : ariaValueText[index],\n      \"aria-valuemin\": bounds.min,\n      \"aria-valuemax\": bounds.max,\n      \"aria-valuenow\": valueAtIndex,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel == null ? void 0 : ariaLabel[index],\n      \"aria-labelledby\": (ariaLabel == null ? void 0 : ariaLabel[index]) ? void 0 : ariaLabelledBy == null ? void 0 : ariaLabelledBy[index],\n      style: { ...props2.style,\n        ...getThumbStyle(index)\n      },\n      onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props2.onFocus, () => {\n        setFocused(true);\n        setActiveIndex(index);\n      }),\n      onBlur: callAllHandlers(props2.onBlur, () => {\n        setFocused(false);\n        setActiveIndex(-1);\n      })\n    };\n  }, [ids, value, valueBounds, isInteractive, isDragging, activeIndex, getAriaValueText, ariaValueText, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused]);\n  const getOutputProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return { ...props2,\n      ref,\n      id: ids.output,\n      htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n      \"aria-live\": \"off\"\n    };\n  }, [ids, value]);\n  const getMarkerProps = useCallback(function (props2) {\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const {\n      value: v,\n      ...rest\n    } = props2;\n    const isInRange = !(v < min || v > max);\n    const isHighlighted = v >= value[0] && v <= value[value.length - 1];\n    let percent = valueToPercent(v, min, max);\n    percent = isReversed ? 100 - percent : percent;\n    const markerStyle = {\n      position: \"absolute\",\n      pointerEvents: \"none\",\n      ...orient({\n        orientation,\n        vertical: {\n          bottom: `${percent}%`\n        },\n        horizontal: {\n          left: `${percent}%`\n        }\n      })\n    };\n    return { ...rest,\n      ref,\n      id: ids.getMarker(props2.value),\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: { ...props2.style,\n        ...markerStyle\n      }\n    };\n  }, [isDisabled, isReversed, max, min, orientation, value, ids]);\n  const getInputProps = useCallback(function (props2) {\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const {\n      index,\n      ...rest\n    } = props2;\n    return { ...rest,\n      ref,\n      id: ids.getInput(index),\n      type: \"hidden\",\n      value: value[index],\n      name: Array.isArray(name) ? name[index] : `${name}-${index}`\n    };\n  }, [name, value, ids]);\n  const state = {\n    value,\n    isFocused,\n    isDragging,\n    getThumbPercent: index => thumbPercents[index],\n    getThumbMinValue: index => valueBounds[index].min,\n    getThumbMaxValue: index => valueBounds[index].max\n  };\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps\n  };\n}\n\nfunction getValueBounds(arr, min, max, spacing) {\n  return arr.map((v, i) => {\n    const _min = i === 0 ? min : arr[i - 1] + spacing;\n\n    const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing;\n\n    return {\n      min: _min,\n      max: _max\n    };\n  });\n}\n\nexport { useRangeSlider };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/slider/src/use-range-slider.ts"],"names":["step","value","props"],"mappings":"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","sourcesContent":["import { usePanEvent } from \"@chakra-ui/react-use-pan-event\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport type { PropGetter, RequiredPropGetter } from \"@chakra-ui/react-types\"\nimport { ariaAttr, callAllHandlers, dataAttr } from \"@chakra-ui/utils\"\nimport {\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n  clampValue,\n} from \"@chakra-ui/number-utils\"\nimport { useCallback, useMemo, useRef, useState, useId } from \"react\"\nimport { getIds, getIsReversed, getStyles, orient } from \"./slider-utils\"\nimport { useSizes } from \"@chakra-ui/react-use-size\"\n\nexport interface UseRangeSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number[]\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number[]\n  /**\n   * Orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   * @default false\n   */\n  isReversed?: boolean\n\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number[]): void\n\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number[]): void\n\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number[]): void\n\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string | string[]\n  /**\n   * If `true`, the slider will be disabled\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   * @default false\n   */\n  isReadOnly?: boolean\n\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string[]\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string[]\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string[]\n  /**\n   * The writing mode\n   * @default \"ltr\"\n   */\n  direction?: \"ltr\" | \"rtl\"\n  /**\n   * The minimum distance between slider thumbs. Useful for preventing\n   * the thumbs from being too close together.\n   * @default 0\n   */\n  minStepsBetweenThumbs?: number\n}\n\nexport interface RangeSliderState {\n  value: number[]\n  isFocused: boolean\n  isDragging: boolean\n  getThumbPercent: (index: number) => number\n  getThumbMinValue: (index: number) => number\n  getThumbMaxValue: (index: number) => number\n}\n\nexport interface RangeSliderActions {\n  setValueAtIndex(index: number, val: number): void\n  setActiveIndex: React.Dispatch<React.SetStateAction<number>>\n  stepUp(index: number, step?: number): void\n  stepDown(index: number, step?: number): void\n  reset(): void\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/slidertwothumb/\n */\nexport function useRangeSlider(props: UseRangeSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    minStepsBetweenThumbs = 0,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  const [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? [25, 75],\n    onChange,\n  })\n\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(\n      `[range-slider] You passed an invalid value for \\`value\\` or \\`defaultValue\\`, expected \\`Array\\` but got \\`${typeof valueState}\\``,\n    )\n  }\n\n  const [isDragging, setDragging] = useState(false)\n  const [isFocused, setFocused] = useState(false)\n  const [activeIndex, setActiveIndex] = useState(-1)\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  const initialValue = useRef(valueState)\n  const value = valueState.map((val) => clampValue(val, min, max))\n\n  const spacing = minStepsBetweenThumbs * step\n  const valueBounds = getValueBounds(value, min, max, spacing)\n\n  const stateRef = useRef<{\n    eventSource: \"pointer\" | \"keyboard\" | null\n    value: number[]\n    valueBounds: Array<{ min: number; max: number }>\n  }>({\n    eventSource: null,\n    value: [],\n    valueBounds: [],\n  })\n\n  stateRef.current.value = value\n  stateRef.current.valueBounds = valueBounds\n\n  const reversedValue = value.map((val) => max - val + min)\n  const thumbValues = isReversed ? reversedValue : value\n  const thumbPercents = thumbValues.map((val) => valueToPercent(val, min, max))\n\n  const isVertical = orientation === \"vertical\"\n\n  const trackRef = useRef<HTMLElement>(null)\n  const rootRef = useRef<HTMLElement>(null)\n\n  const thumbRects = useSizes({\n    getNodes() {\n      const rootNode = rootRef.current\n      const thumbNodes =\n        rootNode?.querySelectorAll<HTMLElement>(\"[role=slider]\")\n      return thumbNodes ? Array.from(thumbNodes) : []\n    },\n  })\n\n  const reactId = useId()\n  const uuid = idProp ?? reactId\n  const ids = getIds(uuid)\n\n  const getValueFromPointer = useCallback(\n    (event: any) => {\n      if (!trackRef.current) return\n      stateRef.current.eventSource = \"pointer\"\n      const rect = trackRef.current.getBoundingClientRect()\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical ? rect.bottom - clientY : clientX - rect.left\n      const length = isVertical ? rect.height : rect.width\n\n      let percent = diff / length\n      if (isReversed) percent = 1 - percent\n\n      return percentToValue(percent, min, max)\n    },\n    [isVertical, isReversed, max, min],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const actions: RangeSliderActions = useMemo(\n    () => ({\n      setValueAtIndex(index: number, val: number) {\n        if (!isInteractive) return\n        const bounds = stateRef.current.valueBounds[index]\n        val = parseFloat(roundValueToStep(val, bounds.min, oneStep))\n        val = clampValue(val, bounds.min, bounds.max)\n        const next = [...stateRef.current.value]\n        next[index] = val\n        setValue(next)\n      },\n      setActiveIndex,\n      stepUp(index: number, step = oneStep) {\n        const valueAtIndex = stateRef.current.value[index]\n        const next = isReversed ? valueAtIndex - step : valueAtIndex + step\n        actions.setValueAtIndex(index, next)\n      },\n      stepDown(index: number, step = oneStep) {\n        const valueAtIndex = stateRef.current.value[index]\n        const next = isReversed ? valueAtIndex + step : valueAtIndex - step\n        actions.setValueAtIndex(index, next)\n      },\n      reset() {\n        setValue(initialValue.current)\n      },\n    }),\n    [oneStep, isReversed, setValue, isInteractive],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = event.key\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        ArrowRight: () => actions.stepUp(activeIndex),\n        ArrowUp: () => actions.stepUp(activeIndex),\n        ArrowLeft: () => actions.stepDown(activeIndex),\n        ArrowDown: () => actions.stepDown(activeIndex),\n        PageUp: () => actions.stepUp(activeIndex, tenSteps),\n        PageDown: () => actions.stepDown(activeIndex, tenSteps),\n        Home: () => {\n          const { min: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n        End: () => {\n          const { max: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        stateRef.current.eventSource = \"keyboard\"\n      }\n    },\n    [actions, activeIndex, tenSteps, valueBounds],\n  )\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = useMemo(\n    () =>\n      getStyles({\n        isReversed,\n        orientation,\n        thumbRects,\n        thumbPercents,\n      }),\n    [isReversed, orientation, thumbPercents, thumbRects],\n  )\n\n  const focusThumb = useCallback(\n    (index?: number) => {\n      const idx = index ?? activeIndex\n      if (idx !== -1 && focusThumbOnChange) {\n        const id = ids.getThumb(idx)\n        const thumb = rootRef.current?.ownerDocument.getElementById(id)\n        if (thumb) {\n          setTimeout(() => thumb.focus())\n        }\n      }\n    },\n    [focusThumbOnChange, activeIndex, ids],\n  )\n\n  useUpdateEffect(() => {\n    if (stateRef.current.eventSource === \"keyboard\") {\n      onChangeEnd?.(stateRef.current.value)\n    }\n  }, [value, onChangeEnd])\n\n  const onPanSessionStart = (event: MouseEvent | TouchEvent | PointerEvent) => {\n    const pointValue = getValueFromPointer(event) || 0\n    const distances = stateRef.current.value.map((val) =>\n      Math.abs(val - pointValue),\n    )\n    const closest = Math.min(...distances)\n    let index = distances.indexOf(closest)\n\n    // check if the clicked thumb is stacked by checking if there are multiple\n    // thumbs at the same distance\n    const thumbsAtPosition = distances.filter(\n      (distance) => distance === closest,\n    )\n    const isThumbStacked = thumbsAtPosition.length > 1\n\n    // when two thumbs are stacked and the user clicks at a point larger than\n    // their values, pick the last thumb with the greatest index\n    if (isThumbStacked && pointValue > stateRef.current.value[index]) {\n      index = index + thumbsAtPosition.length - 1\n    }\n\n    setActiveIndex(index)\n    actions.setValueAtIndex(index, pointValue)\n    focusThumb(index)\n  }\n\n  const onPan = (event: MouseEvent | TouchEvent | PointerEvent) => {\n    if (activeIndex == -1) return\n    const pointValue = getValueFromPointer(event) || 0\n    setActiveIndex(activeIndex)\n    actions.setValueAtIndex(activeIndex, pointValue)\n    focusThumb(activeIndex)\n  }\n\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging(true)\n      onPanSessionStart(event)\n      onChangeStart?.(stateRef.current.value)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging(false)\n      onChangeEnd?.(stateRef.current.value)\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      onPan(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ...htmlProps,\n        id: ids.root,\n        ref: mergeRefs(ref, rootRef),\n        tabIndex: -1,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"data-focused\": dataAttr(isFocused),\n        style: { ...props.style, ...rootStyle },\n      }\n    },\n    [htmlProps, isDisabled, isFocused, rootStyle, ids],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref: mergeRefs(ref, trackRef),\n        id: ids.track,\n        \"data-disabled\": dataAttr(isDisabled),\n        style: { ...props.style, ...trackStyle },\n      }\n    },\n    [isDisabled, trackStyle, ids],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        id: ids.innerTrack,\n        style: {\n          ...props.style,\n          ...innerTrackStyle,\n        },\n      }\n    },\n    [innerTrackStyle, ids],\n  )\n\n  const getThumbProps: RequiredPropGetter<{ index: number }> = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n\n      const valueAtIndex = value[index]\n      if (valueAtIndex == null) {\n        throw new TypeError(\n          `[range-slider > thumb] Cannot find value at index \\`${index}\\`. The \\`value\\` or \\`defaultValue\\` length is : ${value.length}`,\n        )\n      }\n\n      const bounds = valueBounds[index]\n\n      return {\n        ...rest,\n        ref,\n        role: \"slider\",\n        tabIndex: isInteractive ? 0 : undefined,\n        id: ids.getThumb(index),\n        \"data-active\": dataAttr(isDragging && activeIndex === index),\n        \"aria-valuetext\":\n          getAriaValueText?.(valueAtIndex) ?? ariaValueText?.[index],\n        \"aria-valuemin\": bounds.min,\n        \"aria-valuemax\": bounds.max,\n        \"aria-valuenow\": valueAtIndex,\n        \"aria-orientation\": orientation,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"aria-readonly\": ariaAttr(isReadOnly),\n        \"aria-label\": ariaLabel?.[index],\n        \"aria-labelledby\": ariaLabel?.[index]\n          ? undefined\n          : ariaLabelledBy?.[index],\n        style: { ...props.style, ...getThumbStyle(index) },\n        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(props.onFocus, () => {\n          setFocused(true)\n          setActiveIndex(index)\n        }),\n        onBlur: callAllHandlers(props.onBlur, () => {\n          setFocused(false)\n          setActiveIndex(-1)\n        }),\n      }\n    },\n    [\n      ids,\n      value,\n      valueBounds,\n      isInteractive,\n      isDragging,\n      activeIndex,\n      getAriaValueText,\n      ariaValueText,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n      setFocused,\n    ],\n  )\n\n  const getOutputProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        id: ids.output,\n        htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n        \"aria-live\": \"off\",\n      }\n    },\n    [ids, value],\n  )\n\n  const getMarkerProps: RequiredPropGetter<{ value: number }> = useCallback(\n    (props, ref = null) => {\n      const { value: v, ...rest } = props\n\n      const isInRange = !(v < min || v > max)\n      const isHighlighted = v >= value[0] && v <= value[value.length - 1]\n\n      let percent = valueToPercent(v, min, max)\n      percent = isReversed ? 100 - percent : percent\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: { bottom: `${percent}%` },\n          horizontal: { left: `${percent}%` },\n        }),\n      }\n\n      return {\n        ...rest,\n        ref,\n        id: ids.getMarker(props.value),\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value, ids],\n  )\n\n  const getInputProps: RequiredPropGetter<{ index: number }> = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n      return {\n        ...rest,\n        ref,\n        id: ids.getInput(index),\n        type: \"hidden\",\n        value: value[index],\n        name: Array.isArray(name) ? name[index] : `${name}-${index}`,\n      }\n    },\n    [name, value, ids],\n  )\n\n  const state: RangeSliderState = {\n    value,\n    isFocused,\n    isDragging,\n    getThumbPercent: (index: number) => thumbPercents[index],\n    getThumbMinValue: (index: number) => valueBounds[index].min,\n    getThumbMaxValue: (index: number) => valueBounds[index].max,\n  }\n\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps,\n  }\n}\n\nexport type UseRangeSliderReturn = ReturnType<typeof useRangeSlider>\n\nfunction getValueBounds(\n  arr: number[],\n  min: number,\n  max: number,\n  spacing: number,\n) {\n  return arr.map((v, i) => {\n    const _min = i === 0 ? min : arr[i - 1] + spacing\n    const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing\n    return { min: _min, max: _max }\n  })\n}\n"]},"metadata":{},"sourceType":"module"}