{"ast":null,"code":"import { mixNumber as mixNumber$1 } from './number.mjs';\nimport { mixColor } from './color.mjs';\nimport { pipe } from '../pipe.mjs';\nimport { warning } from '../errors.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\nimport { mixImmediate } from './immediate.mjs';\n\nfunction mixNumber(a, b) {\n  return p => mixNumber$1(a, b, p);\n}\n\nfunction getMixer(a) {\n  if (typeof a === \"number\") {\n    return mixNumber;\n  } else if (typeof a === \"string\") {\n    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;\n  } else if (Array.isArray(a)) {\n    return mixArray;\n  } else if (typeof a === \"object\") {\n    return color.test(a) ? mixColor : mixObject;\n  }\n\n  return mixImmediate;\n}\n\nfunction mixArray(a, b) {\n  const output = [...a];\n  const numValues = output.length;\n  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n  return p => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](p);\n    }\n\n    return output;\n  };\n}\n\nfunction mixObject(a, b) {\n  const output = { ...a,\n    ...b\n  };\n  const blendValue = {};\n\n  for (const key in output) {\n    if (a[key] !== undefined && b[key] !== undefined) {\n      blendValue[key] = getMixer(a[key])(a[key], b[key]);\n    }\n  }\n\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n\n    return output;\n  };\n}\n\nfunction matchOrder(origin, target) {\n  var _a;\n\n  const orderedOrigin = [];\n  const pointers = {\n    color: 0,\n    var: 0,\n    number: 0\n  };\n\n  for (let i = 0; i < target.values.length; i++) {\n    const type = target.types[i];\n    const originIndex = origin.indexes[type][pointers[type]];\n    const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n    orderedOrigin[i] = originValue;\n    pointers[type]++;\n  }\n\n  return orderedOrigin;\n}\n\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;\n\n  if (canInterpolate) {\n    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {\n      return mixVisibility(origin, target);\n    }\n\n    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return mixImmediate(origin, target);\n  }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/framer-motion/dist/es/utils/mix/complex.mjs"],"names":["mixNumber","mixNumber$1","mixColor","pipe","warning","color","complex","analyseComplexValue","isCSSVariableToken","invisibleValues","mixVisibility","mixImmediate","a","b","p","getMixer","test","mixComplex","Array","isArray","mixArray","mixObject","output","numValues","length","blendValue","map","v","i","key","undefined","matchOrder","origin","target","_a","orderedOrigin","pointers","var","number","values","type","types","originIndex","indexes","originValue","template","createTransformer","originStats","targetStats","canInterpolate","has"],"mappings":"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","sourcesContent":["import { mixNumber as mixNumber$1 } from './number.mjs';\nimport { mixColor } from './color.mjs';\nimport { pipe } from '../pipe.mjs';\nimport { warning } from '../errors.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\nimport { mixImmediate } from './immediate.mjs';\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    var _a;\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };\n"]},"metadata":{},"sourceType":"module"}