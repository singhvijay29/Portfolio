{"ast":null,"code":"'use client'; // src/get-next-item-from-search.ts\n\nfunction getNextItemFromSearch(items, searchString, itemToString, currentItem) {\n  if (searchString == null) {\n    return currentItem;\n  }\n\n  if (!currentItem) {\n    const foundItem = items.find(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));\n    return foundItem;\n  }\n\n  const matchingItems = items.filter(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));\n\n  if (matchingItems.length > 0) {\n    let nextIndex;\n\n    if (matchingItems.includes(currentItem)) {\n      const currentIndex = matchingItems.indexOf(currentItem);\n      nextIndex = currentIndex + 1;\n\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0;\n      }\n\n      return matchingItems[nextIndex];\n    }\n\n    nextIndex = items.indexOf(matchingItems[0]);\n    return items[nextIndex];\n  }\n\n  return currentItem;\n}\n\nexport { getNextItemFromSearch };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/menu/src/get-next-item-from-search.ts"],"names":[],"mappings":";;AAQO,SAAS,qBAAT,CACL,KADK,EAEL,YAFK,EAGL,YAHK,EAIL,WAJK,EAKU;AACf,MAAI,YAAA,IAAgB,IAApB,EAA0B;AACxB,WAAO,WAAP;AACF;;AAGA,MAAI,CAAC,WAAL,EAAkB;AAChB,UAAM,SAAA,GAAY,KAAA,CAAM,IAAN,CAAY,IAAD,IAC3B,YAAA,CAAa,IAAb,CAAA,CAAmB,WAAnB,GAAiC,UAAjC,CAA4C,YAAA,CAAa,WAAb,EAA5C,CADgB,CAAlB;AAGA,WAAO,SAAP;AACF;;AAGA,QAAM,aAAA,GAAgB,KAAA,CAAM,MAAN,CAAc,IAAD,IACjC,YAAA,CAAa,IAAb,CAAA,CAAmB,WAAnB,GAAiC,UAAjC,CAA4C,YAAA,CAAa,WAAb,EAA5C,CADoB,CAAtB;;AAKA,MAAI,aAAA,CAAc,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,QAAI,SAAJ;;AAGA,QAAI,aAAA,CAAc,QAAd,CAAuB,WAAvB,CAAJ,EAAyC;AACvC,YAAM,YAAA,GAAe,aAAA,CAAc,OAAd,CAAsB,WAAtB,CAArB;AACA,MAAA,SAAA,GAAY,YAAA,GAAe,CAA3B;;AACA,UAAI,SAAA,KAAc,aAAA,CAAc,MAAhC,EAAwC;AACtC,QAAA,SAAA,GAAY,CAAZ;AACF;;AACA,aAAO,aAAA,CAAc,SAAd,CAAP;AACF;;AAEA,IAAA,SAAA,GAAY,KAAA,CAAM,OAAN,CAAc,aAAA,CAAc,CAAd,CAAd,CAAZ;AACA,WAAO,KAAA,CAAM,SAAN,CAAP;AACF;;AAGA,SAAO,WAAP;AACF","sourcesContent":["/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\nexport function getNextItemFromSearch<T>(\n  items: T[],\n  searchString: string,\n  itemToString: (item: T) => string,\n  currentItem: T,\n): T | undefined {\n  if (searchString == null) {\n    return currentItem\n  }\n\n  // If current item doesn't exist, find the item that matches the search string\n  if (!currentItem) {\n    const foundItem = items.find((item) =>\n      itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()),\n    )\n    return foundItem\n  }\n\n  // Filter items for ones that match the search string (case insensitive)\n  const matchingItems = items.filter((item) =>\n    itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()),\n  )\n\n  // If there's a match, let's get the next item to select\n  if (matchingItems.length > 0) {\n    let nextIndex: number\n\n    // If the currentItem is in the available items, we move to the next available option\n    if (matchingItems.includes(currentItem)) {\n      const currentIndex = matchingItems.indexOf(currentItem)\n      nextIndex = currentIndex + 1\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0\n      }\n      return matchingItems[nextIndex]\n    }\n    // Else, we pick the first item in the available items\n    nextIndex = items.indexOf(matchingItems[0])\n    return items[nextIndex]\n  }\n\n  // a decent fallback to the currentItem\n  return currentItem\n}\n"]},"metadata":{},"sourceType":"module"}