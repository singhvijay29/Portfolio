{"ast":null,"code":"import { jsx, Fragment } from 'react/jsx-runtime';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { invariant } from '../../utils/errors.mjs';\n\nconst getChildKey = child => child.key || \"\";\n\nfunction updateChildLookup(children, allChildren) {\n  children.forEach(child => {\n    const key = getChildKey(child);\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  const filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, child => {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nconst AnimatePresence = _ref => {\n  let {\n    children,\n    custom,\n    initial = true,\n    onExitComplete,\n    exitBeforeEnter,\n    presenceAffectsLayout = true,\n    mode = \"sync\"\n  } = _ref;\n  invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\"); // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  const forceRender = useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];\n  const isMounted = useIsMounted(); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  const filteredChildren = onlyElements(children);\n  let childrenToRender = filteredChildren;\n  const exitingChildren = useRef(new Map()).current; // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  const presentChildren = useRef(childrenToRender); // A lookup table to quickly reference components by key\n\n  const allChildren = useRef(new Map()).current; // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  const isInitialRender = useRef(true);\n  useIsomorphicLayoutEffect(() => {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  useUnmountEffect(() => {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exitingChildren.clear();\n  });\n\n  if (isInitialRender.current) {\n    return jsx(Fragment, {\n      children: childrenToRender.map(child => jsx(PresenceChild, {\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode,\n        children: child\n      }, getChildKey(child)))\n    });\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  childrenToRender = [...childrenToRender]; // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n  const presentKeys = presentChildren.current.map(getChildKey);\n  const targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  const numPresent = presentKeys.length;\n\n  for (let i = 0; i < numPresent; i++) {\n    const key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\n      exitingChildren.set(key, undefined);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (mode === \"wait\" && exitingChildren.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exitingChildren.forEach((component, key) => {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    const child = allChildren.get(key);\n    if (!child) return;\n    const insertionIndex = presentKeys.indexOf(key);\n    let exitingComponent = component;\n\n    if (!exitingComponent) {\n      const onExit = () => {\n        // clean up the exiting children map\n        exitingChildren.delete(key); // compute the keys of children that were rendered once but are no longer present\n        // this could happen in case of too many fast consequent renderings\n        // @link https://github.com/framer/motion/issues/2023\n\n        const leftOverKeys = Array.from(allChildren.keys()).filter(childKey => !targetKeys.includes(childKey)); // clean up the all children map\n\n        leftOverKeys.forEach(leftOverKey => allChildren.delete(leftOverKey)); // make sure to render only the children that are actually visible\n\n        presentChildren.current = filteredChildren.filter(presentChild => {\n          const presentChildKey = getChildKey(presentChild);\n          return (// filter out the node exiting\n            presentChildKey === key || // filter out the leftover children\n            leftOverKeys.includes(presentChildKey)\n          );\n        }); // Defer re-rendering until all exiting children have indeed left\n\n        if (!exitingChildren.size) {\n          if (isMounted.current === false) return;\n          forceRender();\n          onExitComplete && onExitComplete();\n        }\n      };\n\n      exitingComponent = jsx(PresenceChild, {\n        isPresent: false,\n        onExitComplete: onExit,\n        custom: custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode,\n        children: child\n      }, getChildKey(child));\n      exitingChildren.set(key, exitingComponent);\n    }\n\n    childrenToRender.splice(insertionIndex, 0, exitingComponent);\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(child => {\n    const key = child.key;\n    return exitingChildren.has(key) ? child : jsx(PresenceChild, {\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode,\n      children: child\n    }, getChildKey(child));\n  });\n\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && childrenToRender.length > 1) {\n    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n  }\n\n  return jsx(Fragment, {\n    children: exitingChildren.size ? childrenToRender : childrenToRender.map(child => cloneElement(child))\n  });\n};\n\nexport { AnimatePresence };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"names":["jsx","Fragment","useContext","useRef","cloneElement","Children","isValidElement","useForceUpdate","useIsMounted","PresenceChild","LayoutGroupContext","useIsomorphicLayoutEffect","useUnmountEffect","invariant","getChildKey","child","key","updateChildLookup","children","allChildren","forEach","set","onlyElements","filtered","push","AnimatePresence","custom","initial","onExitComplete","exitBeforeEnter","presenceAffectsLayout","mode","forceRender","isMounted","filteredChildren","childrenToRender","exitingChildren","Map","current","presentChildren","isInitialRender","clear","map","isPresent","undefined","presentKeys","targetKeys","numPresent","length","i","indexOf","has","size","component","get","insertionIndex","exitingComponent","onExit","delete","leftOverKeys","Array","from","keys","filter","childKey","includes","leftOverKey","presentChild","presentChildKey","splice","process","env","NODE_ENV","console","warn"],"mappings":"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","sourcesContent":["import { jsx, Fragment } from 'react/jsx-runtime';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { invariant } from '../../utils/errors.mjs';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction updateChildLookup(children, allChildren) {\n    children.forEach((child) => {\n        const key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = \"sync\", }) => {\n    invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    const forceRender = useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];\n    const isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    const filteredChildren = onlyElements(children);\n    let childrenToRender = filteredChildren;\n    const exitingChildren = useRef(new Map()).current;\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    const presentChildren = useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    const allChildren = useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    const isInitialRender = useRef(true);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(() => {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exitingChildren.clear();\n    });\n    if (isInitialRender.current) {\n        return (jsx(Fragment, { children: childrenToRender.map((child) => (jsx(PresenceChild, { isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout, mode: mode, children: child }, getChildKey(child)))) }));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = [...childrenToRender];\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    const presentKeys = presentChildren.current.map(getChildKey);\n    const targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    const numPresent = presentKeys.length;\n    for (let i = 0; i < numPresent; i++) {\n        const key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\n            exitingChildren.set(key, undefined);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (mode === \"wait\" && exitingChildren.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exitingChildren.forEach((component, key) => {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        const child = allChildren.get(key);\n        if (!child)\n            return;\n        const insertionIndex = presentKeys.indexOf(key);\n        let exitingComponent = component;\n        if (!exitingComponent) {\n            const onExit = () => {\n                // clean up the exiting children map\n                exitingChildren.delete(key);\n                // compute the keys of children that were rendered once but are no longer present\n                // this could happen in case of too many fast consequent renderings\n                // @link https://github.com/framer/motion/issues/2023\n                const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));\n                // clean up the all children map\n                leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));\n                // make sure to render only the children that are actually visible\n                presentChildren.current = filteredChildren.filter((presentChild) => {\n                    const presentChildKey = getChildKey(presentChild);\n                    return (\n                    // filter out the node exiting\n                    presentChildKey === key ||\n                        // filter out the leftover children\n                        leftOverKeys.includes(presentChildKey));\n                });\n                // Defer re-rendering until all exiting children have indeed left\n                if (!exitingChildren.size) {\n                    if (isMounted.current === false)\n                        return;\n                    forceRender();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            exitingComponent = (jsx(PresenceChild, { isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, children: child }, getChildKey(child)));\n            exitingChildren.set(key, exitingComponent);\n        }\n        childrenToRender.splice(insertionIndex, 0, exitingComponent);\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map((child) => {\n        const key = child.key;\n        return exitingChildren.has(key) ? (child) : (jsx(PresenceChild, { isPresent: true, presenceAffectsLayout: presenceAffectsLayout, mode: mode, children: child }, getChildKey(child)));\n    });\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        childrenToRender.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    return (jsx(Fragment, { children: exitingChildren.size\n            ? childrenToRender\n            : childrenToRender.map((child) => cloneElement(child)) }));\n};\n\nexport { AnimatePresence };\n"]},"metadata":{},"sourceType":"module"}