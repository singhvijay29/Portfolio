{"ast":null,"code":"'use client'; // src/use-pin-input.ts\n\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { ariaAttr, callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { useCallback, useEffect, useState, useId } from \"react\";\nvar [PinInputDescendantsProvider, usePinInputDescendantsContext, usePinInputDescendants, usePinInputDescendant] = createDescendantContext();\nvar [PinInputProvider, usePinInputContext] = createContext({\n  name: \"PinInputContext\",\n  errorMessage: \"usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`\"\n});\n\nvar toArray = value => value == null ? void 0 : value.split(\"\");\n\nfunction validate(value, type) {\n  const NUMERIC_REGEX = /^[0-9]+$/;\n  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;\n  const regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;\n  return regex.test(value);\n}\n\nfunction usePinInput() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    autoFocus,\n    value,\n    defaultValue,\n    onChange,\n    onComplete,\n    placeholder = \"\\u25CB\",\n    manageFocus = true,\n    otp = false,\n    id: idProp,\n    isDisabled,\n    isInvalid,\n    type = \"number\",\n    mask\n  } = props;\n  const uuid = useId();\n  const id = idProp != null ? idProp : `pin-input-${uuid}`;\n  const descendants = usePinInputDescendants();\n  const [moveFocus, setMoveFocus] = useState(true);\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  const [values, setValues] = useControllableState({\n    defaultValue: toArray(defaultValue) || [],\n    value: toArray(value),\n    onChange: values2 => onChange == null ? void 0 : onChange(values2.join(\"\"))\n  });\n  useEffect(() => {\n    if (autoFocus) {\n      const first = descendants.first();\n\n      if (first) {\n        requestAnimationFrame(() => {\n          first.node.focus();\n        });\n      }\n    }\n  }, [descendants]);\n  const focusNext = useCallback(index => {\n    if (!moveFocus || !manageFocus) return;\n    const next = descendants.next(index, false);\n\n    if (next) {\n      requestAnimationFrame(() => {\n        next.node.focus();\n      });\n    }\n  }, [descendants, moveFocus, manageFocus]);\n  const setValue = useCallback(function (value2, index) {\n    let handleFocus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const nextValues = [...values];\n    nextValues[index] = value2;\n    setValues(nextValues);\n    const isComplete = value2 !== \"\" && nextValues.length === descendants.count() && nextValues.every(inputValue => inputValue != null && inputValue !== \"\");\n\n    if (isComplete) {\n      onComplete == null ? void 0 : onComplete(nextValues.join(\"\"));\n    } else {\n      if (handleFocus) focusNext(index);\n    }\n  }, [values, setValues, focusNext, onComplete, descendants]);\n  const clear = useCallback(() => {\n    var _a;\n\n    const values2 = Array(descendants.count()).fill(\"\");\n    setValues(values2);\n    const first = descendants.first();\n    (_a = first == null ? void 0 : first.node) == null ? void 0 : _a.focus();\n  }, [descendants, setValues]);\n  const getNextValue = useCallback((value2, eventValue) => {\n    let nextValue = eventValue;\n\n    if ((value2 == null ? void 0 : value2.length) > 0) {\n      if (value2[0] === eventValue.charAt(0)) {\n        nextValue = eventValue.charAt(1);\n      } else if (value2[0] === eventValue.charAt(1)) {\n        nextValue = eventValue.charAt(0);\n      }\n    }\n\n    return nextValue;\n  }, []);\n  const getInputProps = useCallback(props2 => {\n    const {\n      index,\n      ...rest\n    } = props2;\n\n    const onChange2 = event => {\n      const eventValue = event.target.value;\n      const currentValue = values[index];\n      const nextValue = getNextValue(currentValue, eventValue);\n\n      if (nextValue === \"\") {\n        setValue(\"\", index);\n        return;\n      }\n\n      if (eventValue.length > 2) {\n        if (validate(eventValue, type)) {\n          const nextValue2 = eventValue.split(\"\").filter((_, index2) => index2 < descendants.count());\n          setValues(nextValue2);\n\n          if (nextValue2.length === descendants.count()) {\n            onComplete == null ? void 0 : onComplete(nextValue2.join(\"\"));\n          }\n        }\n      } else {\n        if (validate(nextValue, type)) {\n          setValue(nextValue, index);\n        }\n\n        setMoveFocus(true);\n      }\n    };\n\n    const onKeyDown = event => {\n      var _a;\n\n      if (event.key === \"Backspace\" && manageFocus) {\n        if (event.target.value === \"\") {\n          const prevInput = descendants.prev(index, false);\n\n          if (prevInput) {\n            setValue(\"\", index - 1, false);\n            (_a = prevInput.node) == null ? void 0 : _a.focus();\n            setMoveFocus(true);\n          }\n        } else {\n          setMoveFocus(false);\n        }\n      }\n    };\n\n    const onFocus = () => {\n      setFocusedIndex(index);\n    };\n\n    const onBlur = () => {\n      setFocusedIndex(-1);\n    };\n\n    const hasFocus = focusedIndex === index;\n    const inputType = type === \"number\" ? \"tel\" : \"text\";\n    return {\n      \"aria-label\": \"Please enter your pin code\",\n      inputMode: type === \"number\" ? \"numeric\" : \"text\",\n      type: mask ? \"password\" : inputType,\n      ...rest,\n      id: `${id}-${index}`,\n      disabled: isDisabled,\n      \"aria-invalid\": ariaAttr(isInvalid),\n      onChange: callAllHandlers(rest.onChange, onChange2),\n      onKeyDown: callAllHandlers(rest.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(rest.onFocus, onFocus),\n      onBlur: callAllHandlers(rest.onBlur, onBlur),\n      value: values[index] || \"\",\n      autoComplete: otp ? \"one-time-code\" : \"off\",\n      placeholder: hasFocus ? \"\" : placeholder\n    };\n  }, [descendants, focusedIndex, getNextValue, id, isDisabled, mask, isInvalid, manageFocus, onComplete, otp, placeholder, setValue, setValues, type, values]);\n  return {\n    // prop getter\n    getInputProps,\n    // state\n    id,\n    descendants,\n    values,\n    // actions\n    setValue,\n    setValues,\n    clear\n  };\n}\n\nfunction usePinInputField() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const {\n    getInputProps\n  } = usePinInputContext();\n  const {\n    index,\n    register\n  } = usePinInputDescendant();\n  return getInputProps({ ...props,\n    ref: mergeRefs(register, ref),\n    index\n  });\n}\n\nexport { PinInputDescendantsProvider, usePinInputDescendantsContext, usePinInputDescendants, usePinInputDescendant, PinInputProvider, usePinInputContext, usePinInput, usePinInputField };","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/@chakra-ui/pin-input/src/use-pin-input.ts"],"names":["values","value","props","onChange","nextValue","index"],"mappings":"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","sourcesContent":["import { createDescendantContext } from \"@chakra-ui/descendant\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { ariaAttr, callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport { createContext } from \"@chakra-ui/react-context\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { useCallback, useEffect, useState, useId } from \"react\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  PinInputDescendantsProvider,\n  usePinInputDescendantsContext,\n  usePinInputDescendants,\n  usePinInputDescendant,\n] = createDescendantContext<HTMLInputElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * Create context that stores pin-input logic\n * -----------------------------------------------------------------------------------------------*/\n\nexport type PinInputContext = Omit<UsePinInputReturn, \"descendants\"> & {\n  /**\n   * Sets the pin input component to the disabled state\n   */\n  isDisabled?: boolean\n  /**\n   * Sets the pin input component to the invalid state\n   */\n  isInvalid?: boolean\n}\n\nexport const [PinInputProvider, usePinInputContext] =\n  createContext<PinInputContext>({\n    name: \"PinInputContext\",\n    errorMessage:\n      \"usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`\",\n  })\n\n/* -------------------------------------------------------------------------------------------------\n * usePinInput hook\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UsePinInputProps {\n  /**\n   * If `true`, the pin input receives focus on mount\n   */\n  autoFocus?: boolean\n  /**\n   * The value of the pin input. This is the value\n   * that will be returned when the pin input is filled\n   */\n  value?: string\n  /**\n   * The default value of the pin input\n   */\n  defaultValue?: string\n  /**\n   * Function called on input change\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when all inputs have valid values\n   */\n  onComplete?: (value: string) => void\n  /**\n   * The placeholder for the pin input\n   */\n  placeholder?: string\n  /**\n   * If `true`, focus will move automatically to the next input once filled\n   * @default true\n   */\n  manageFocus?: boolean\n  /**\n   * If `true`, the pin input component signals to its fields that they should\n   * use `autocomplete=\"one-time-code\"`.\n   */\n  otp?: boolean\n  /**\n   * The top-level id string that will be applied to the input fields.\n   * The index of the input will be appended to this top-level id.\n   *\n   * @example\n   * if id=\"foo\", the first input will have `foo-0`\n   */\n  id?: string\n  /**\n   * If `true`, the pin input component is put in the disabled state\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the pin input component is put in the invalid state\n   */\n  isInvalid?: boolean\n  /**\n   * The type of values the pin-input should allow\n   */\n  type?: \"alphanumeric\" | \"number\"\n  /**\n   * If `true`, the input's value will be masked just like `type=password`\n   */\n  mask?: boolean\n}\n\nconst toArray = (value?: string) => value?.split(\"\")\n\nfunction validate(value: string, type: UsePinInputProps[\"type\"]) {\n  const NUMERIC_REGEX = /^[0-9]+$/\n  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i\n  const regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX\n  return regex.test(value)\n}\n\n/* -------------------------------------------------------------------------------------------------\n * usePinInput - handles the general pin input logic\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n */\nexport function usePinInput(props: UsePinInputProps = {}) {\n  const {\n    autoFocus,\n    value,\n    defaultValue,\n    onChange,\n    onComplete,\n    placeholder = \"○\",\n    manageFocus = true,\n    otp = false,\n    id: idProp,\n    isDisabled,\n    isInvalid,\n    type = \"number\",\n    mask,\n  } = props\n\n  const uuid = useId()\n  const id = idProp ?? `pin-input-${uuid}`\n\n  const descendants = usePinInputDescendants()\n\n  const [moveFocus, setMoveFocus] = useState(true)\n  const [focusedIndex, setFocusedIndex] = useState(-1)\n\n  const [values, setValues] = useControllableState<string[]>({\n    defaultValue: toArray(defaultValue) || [],\n    value: toArray(value),\n    onChange: (values) => onChange?.(values.join(\"\")),\n  })\n\n  useEffect(() => {\n    if (autoFocus) {\n      const first = descendants.first()\n      if (first) {\n        requestAnimationFrame(() => {\n          first.node.focus()\n        })\n      }\n    }\n    // We don't want to listen for updates to `autoFocus` since it only runs initially\n    // eslint-disable-next-line\n  }, [descendants])\n\n  const focusNext = useCallback(\n    (index: number) => {\n      if (!moveFocus || !manageFocus) return\n      const next = descendants.next(index, false)\n      if (next) {\n        requestAnimationFrame(() => {\n          next.node.focus()\n        })\n      }\n    },\n    [descendants, moveFocus, manageFocus],\n  )\n\n  const setValue = useCallback(\n    (value: string, index: number, handleFocus: boolean = true) => {\n      const nextValues = [...values]\n      nextValues[index] = value\n      setValues(nextValues)\n\n      const isComplete =\n        value !== \"\" &&\n        nextValues.length === descendants.count() &&\n        nextValues.every(\n          (inputValue) => inputValue != null && inputValue !== \"\",\n        )\n\n      if (isComplete) {\n        onComplete?.(nextValues.join(\"\"))\n      } else {\n        if (handleFocus) focusNext(index)\n      }\n    },\n    [values, setValues, focusNext, onComplete, descendants],\n  )\n\n  const clear = useCallback(() => {\n    const values: string[] = Array(descendants.count()).fill(\"\")\n    setValues(values)\n    const first = descendants.first()\n    first?.node?.focus()\n  }, [descendants, setValues])\n\n  const getNextValue = useCallback((value: string, eventValue: string) => {\n    let nextValue = eventValue\n    if (value?.length > 0) {\n      if (value[0] === eventValue.charAt(0)) {\n        nextValue = eventValue.charAt(1)\n      } else if (value[0] === eventValue.charAt(1)) {\n        nextValue = eventValue.charAt(0)\n      }\n    }\n    return nextValue\n  }, [])\n\n  const getInputProps = useCallback(\n    (props: InputProps & { index: number }): InputProps => {\n      const { index, ...rest } = props\n\n      /**\n       * Improved from: https://github.com/uber/baseweb/blob/master/src/pin-code/pin-code.js\n       */\n      const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const eventValue = event.target.value\n        const currentValue = values[index]\n        const nextValue = getNextValue(currentValue, eventValue)\n\n        // if the value was removed using backspace\n        if (nextValue === \"\") {\n          setValue(\"\", index)\n          return\n        }\n\n        // in the case of an autocomplete or copy and paste\n        if (eventValue.length > 2) {\n          // see if we can use the string to fill out our values\n          if (validate(eventValue, type)) {\n            // Ensure the value matches the number of inputs\n            const nextValue = eventValue\n              .split(\"\")\n              .filter((_, index) => index < descendants.count())\n\n            setValues(nextValue)\n\n            // if pasting fills the entire input fields, trigger `onComplete`\n            if (nextValue.length === descendants.count()) {\n              onComplete?.(nextValue.join(\"\"))\n            }\n          }\n        } else {\n          // only set if the new value is a number\n          if (validate(nextValue, type)) {\n            setValue(nextValue, index)\n          }\n\n          setMoveFocus(true)\n        }\n      }\n\n      const onKeyDown = (event: React.KeyboardEvent) => {\n        if (event.key === \"Backspace\" && manageFocus) {\n          if ((event.target as HTMLInputElement).value === \"\") {\n            const prevInput = descendants.prev(index, false)\n            if (prevInput) {\n              setValue(\"\", index - 1, false)\n              prevInput.node?.focus()\n              setMoveFocus(true)\n            }\n          } else {\n            setMoveFocus(false)\n          }\n        }\n      }\n\n      const onFocus = () => {\n        setFocusedIndex(index)\n      }\n\n      const onBlur = () => {\n        setFocusedIndex(-1)\n      }\n\n      const hasFocus = focusedIndex === index\n      const inputType = type === \"number\" ? \"tel\" : \"text\"\n\n      return {\n        \"aria-label\": \"Please enter your pin code\",\n        inputMode: type === \"number\" ? \"numeric\" : \"text\",\n        type: mask ? \"password\" : inputType,\n        ...rest,\n        id: `${id}-${index}`,\n        disabled: isDisabled,\n        \"aria-invalid\": ariaAttr(isInvalid),\n        onChange: callAllHandlers(rest.onChange, onChange),\n        onKeyDown: callAllHandlers(rest.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(rest.onFocus, onFocus),\n        onBlur: callAllHandlers(rest.onBlur, onBlur),\n        value: values[index] || \"\",\n        autoComplete: otp ? \"one-time-code\" : \"off\",\n        placeholder: hasFocus ? \"\" : placeholder,\n      }\n    },\n    [\n      descendants,\n      focusedIndex,\n      getNextValue,\n      id,\n      isDisabled,\n      mask,\n      isInvalid,\n      manageFocus,\n      onComplete,\n      otp,\n      placeholder,\n      setValue,\n      setValues,\n      type,\n      values,\n    ],\n  )\n\n  return {\n    // prop getter\n    getInputProps,\n    // state\n    id,\n    descendants,\n    values,\n    // actions\n    setValue,\n    setValues,\n    clear,\n  }\n}\n\nexport type UsePinInputReturn = ReturnType<typeof usePinInput>\n\nexport interface UsePinInputFieldProps extends InputProps {\n  ref?: React.Ref<HTMLInputElement>\n}\n\n/**\n * @internal\n */\nexport function usePinInputField(\n  props: UsePinInputFieldProps = {},\n  ref: React.Ref<any> = null,\n) {\n  const { getInputProps } = usePinInputContext()\n  const { index, register } = usePinInputDescendant()\n\n  return getInputProps({\n    ...props,\n    ref: mergeRefs(register, ref),\n    index,\n  })\n}\n\ninterface InputProps\n  extends Omit<\n    React.ComponentPropsWithRef<\"input\">,\n    \"color\" | \"height\" | \"width\"\n  > {}\n"]},"metadata":{},"sourceType":"module"}