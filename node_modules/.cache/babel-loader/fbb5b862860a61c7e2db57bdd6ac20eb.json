{"ast":null,"code":"import { getTabbableNodes } from './utils/DOMutils';\n\nfunction weakRef(value) {\n  if (!value) return null; // #68 Safari 14.1 dont have it yet\n  // FIXME: remove in 2025\n\n  if (typeof WeakRef === 'undefined') {\n    return function () {\n      return value || null;\n    };\n  }\n\n  var w = value ? new WeakRef(value) : null;\n  return function () {\n    return (w === null || w === void 0 ? void 0 : w.deref()) || null;\n  };\n}\n\nexport var recordElementLocation = function (element) {\n  if (!element) {\n    return null;\n  }\n\n  var stack = [];\n  var currentElement = element;\n\n  while (currentElement && currentElement !== document.body) {\n    stack.push({\n      current: weakRef(currentElement),\n      parent: weakRef(currentElement.parentElement),\n      left: weakRef(currentElement.previousElementSibling),\n      right: weakRef(currentElement.nextElementSibling)\n    });\n    currentElement = currentElement.parentElement;\n  }\n\n  return {\n    element: weakRef(element),\n    stack: stack,\n    ownerDocument: element.ownerDocument\n  };\n};\n\nvar restoreFocusTo = function (location) {\n  var _a, _b, _c, _d, _e;\n\n  if (!location) {\n    return undefined;\n  }\n\n  var stack = location.stack,\n      ownerDocument = location.ownerDocument;\n  var visibilityCache = new Map();\n\n  for (var _i = 0, stack_1 = stack; _i < stack_1.length; _i++) {\n    var line = stack_1[_i];\n    var parent_1 = (_a = line.parent) === null || _a === void 0 ? void 0 : _a.call(line); // is it still here?\n\n    if (parent_1 && ownerDocument.contains(parent_1)) {\n      var left = (_b = line.left) === null || _b === void 0 ? void 0 : _b.call(line);\n      var savedCurrent = line.current();\n      var current = parent_1.contains(savedCurrent) ? savedCurrent : undefined;\n      var right = (_c = line.right) === null || _c === void 0 ? void 0 : _c.call(line);\n      var focusables = getTabbableNodes([parent_1], visibilityCache);\n      var aim = // that is element itself\n      (_e = (_d = current !== null && current !== void 0 ? current : // or something in it's place\n      left === null || left === void 0 ? void 0 : left.nextElementSibling) !== null && _d !== void 0 ? _d : // or somebody to the right, still close enough\n      right) !== null && _e !== void 0 ? _e : // or somebody to the left, something?\n      left;\n\n      while (aim) {\n        for (var _f = 0, focusables_1 = focusables; _f < focusables_1.length; _f++) {\n          var focusable = focusables_1[_f];\n\n          if (aim === null || aim === void 0 ? void 0 : aim.contains(focusable.node)) {\n            return focusable.node;\n          }\n        }\n\n        aim = aim.nextElementSibling;\n      }\n\n      if (focusables.length) {\n        // if parent contains a focusable - move there\n        return focusables[0].node;\n      }\n    }\n  } // nothing matched\n\n\n  return undefined;\n};\n/**\n * Captures the current focused element to restore focus as close as possible in the future\n * Handles situations where the focused element is removed from the DOM or no longer focusable\n * moving focus to the closest focusable element\n * @param targetElement - element where focus should be restored\n * @returns a function returning a new element to focus\n */\n\n\nexport var captureFocusRestore = function (targetElement) {\n  var location = recordElementLocation(targetElement);\n  return function () {\n    return restoreFocusTo(location);\n  };\n};","map":{"version":3,"sources":["/Users/vijay-chace/Desktop/Portfolio/Portfolio/node_modules/focus-lock/dist/es2015/return-focus.js"],"names":["getTabbableNodes","weakRef","value","WeakRef","w","deref","recordElementLocation","element","stack","currentElement","document","body","push","current","parent","parentElement","left","previousElementSibling","right","nextElementSibling","ownerDocument","restoreFocusTo","location","_a","_b","_c","_d","_e","undefined","visibilityCache","Map","_i","stack_1","length","line","parent_1","call","contains","savedCurrent","focusables","aim","_f","focusables_1","focusable","node","captureFocusRestore","targetElement"],"mappings":"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","sourcesContent":["import { getTabbableNodes } from './utils/DOMutils';\nfunction weakRef(value) {\n    if (!value)\n        return null;\n    // #68 Safari 14.1 dont have it yet\n    // FIXME: remove in 2025\n    if (typeof WeakRef === 'undefined') {\n        return function () { return value || null; };\n    }\n    var w = value ? new WeakRef(value) : null;\n    return function () { return (w === null || w === void 0 ? void 0 : w.deref()) || null; };\n}\nexport var recordElementLocation = function (element) {\n    if (!element) {\n        return null;\n    }\n    var stack = [];\n    var currentElement = element;\n    while (currentElement && currentElement !== document.body) {\n        stack.push({\n            current: weakRef(currentElement),\n            parent: weakRef(currentElement.parentElement),\n            left: weakRef(currentElement.previousElementSibling),\n            right: weakRef(currentElement.nextElementSibling),\n        });\n        currentElement = currentElement.parentElement;\n    }\n    return {\n        element: weakRef(element),\n        stack: stack,\n        ownerDocument: element.ownerDocument,\n    };\n};\nvar restoreFocusTo = function (location) {\n    var _a, _b, _c, _d, _e;\n    if (!location) {\n        return undefined;\n    }\n    var stack = location.stack, ownerDocument = location.ownerDocument;\n    var visibilityCache = new Map();\n    for (var _i = 0, stack_1 = stack; _i < stack_1.length; _i++) {\n        var line = stack_1[_i];\n        var parent_1 = (_a = line.parent) === null || _a === void 0 ? void 0 : _a.call(line);\n        // is it still here?\n        if (parent_1 && ownerDocument.contains(parent_1)) {\n            var left = (_b = line.left) === null || _b === void 0 ? void 0 : _b.call(line);\n            var savedCurrent = line.current();\n            var current = parent_1.contains(savedCurrent) ? savedCurrent : undefined;\n            var right = (_c = line.right) === null || _c === void 0 ? void 0 : _c.call(line);\n            var focusables = getTabbableNodes([parent_1], visibilityCache);\n            var aim = \n            // that is element itself\n            (_e = (_d = current !== null && current !== void 0 ? current : \n            // or something in it's place\n            left === null || left === void 0 ? void 0 : left.nextElementSibling) !== null && _d !== void 0 ? _d : \n            // or somebody to the right, still close enough\n            right) !== null && _e !== void 0 ? _e : \n            // or somebody to the left, something?\n            left;\n            while (aim) {\n                for (var _f = 0, focusables_1 = focusables; _f < focusables_1.length; _f++) {\n                    var focusable = focusables_1[_f];\n                    if (aim === null || aim === void 0 ? void 0 : aim.contains(focusable.node)) {\n                        return focusable.node;\n                    }\n                }\n                aim = aim.nextElementSibling;\n            }\n            if (focusables.length) {\n                // if parent contains a focusable - move there\n                return focusables[0].node;\n            }\n        }\n    }\n    // nothing matched\n    return undefined;\n};\n/**\n * Captures the current focused element to restore focus as close as possible in the future\n * Handles situations where the focused element is removed from the DOM or no longer focusable\n * moving focus to the closest focusable element\n * @param targetElement - element where focus should be restored\n * @returns a function returning a new element to focus\n */\nexport var captureFocusRestore = function (targetElement) {\n    var location = recordElementLocation(targetElement);\n    return function () {\n        return restoreFocusTo(location);\n    };\n};\n"]},"metadata":{},"sourceType":"module"}